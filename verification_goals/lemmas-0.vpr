domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 0
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 0
  requires subtype2 >= 0
  requires subtype2 <= 0
  decreases 
{
  (subtype1 == 0 ==> true) && true
}

method lemmaNonlinear(tid: Int, a: Int, b: Int, maxA: Int)
  returns (res: Void)
  requires 0 <= a
  requires 0 < b
  requires a < maxA
  requires a <= maxA - 1
  decreases b
  ensures a * b <= (maxA - 1) * b
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    exc := null
    if (1 < b) {
      res1 := lemmaNonlinear(tid, a, b - 1, maxA)
      assert a * (b - 1) <= maxA * (b - 1)
    } else {
      assert a <= maxA}
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma2dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires 0 < strideA
  requires extentA * strideA <= strideB
  decreases 
  ensures 0 <= (a - minA) * strideA + (b - minB) * strideB
  ensures (a - minA) * strideA + (b - minB) * strideB < strideB * extentB
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemmaNonlinear(tid, a - minA, strideA, extentA)
    res2 := lemmaNonlinear(tid, b - minB, strideB, extentB)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma3dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int,
  extentC: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires 0 < strideA
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC <
    strideC * extentC
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemma2dAccess(tid, a, minA, strideA, extentA, b, minB, strideB,
      extentB)
    res2 := lemmaNonlinear(tid, c - minC, strideC, extentC)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma4dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int,
  extentC: Int, d: Int, minD: Int, strideD: Int, extentD: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires minD <= d
  requires d - minD < extentD
  requires 0 < strideA
  requires 0 < strideB
  requires 0 < strideC
  requires 0 < strideD
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  requires extentC * strideC <= strideD
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC +
    (d - minD) * strideD
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC +
    (d - minD) * strideD <
    strideD * extentD
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemma3dAccess(tid, a, minA, strideA, extentA, b, minB, strideB,
      extentB, c, minC, strideC, extentC)
    res2 := lemmaNonlinear(tid, d - minD, strideD, extentD)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma5dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int,
  extentC: Int, d: Int, minD: Int, strideD: Int, extentD: Int, e: Int, minE: Int,
  strideE: Int, extentE: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires minD <= d
  requires d - minD < extentD
  requires minE <= e
  requires e - minE < extentE
  requires 0 < strideA
  requires 0 < strideB
  requires 0 < strideC
  requires 0 < strideD
  requires 0 < strideE
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  requires extentC * strideC <= strideD
  requires extentD * strideD <= strideE
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC +
    (d - minD) * strideD +
    (e - minE) * strideE
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC +
    (d - minD) * strideD +
    (e - minE) * strideE <
    strideE * extentE
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemma4dAccess(tid, a, minA, strideA, extentA, b, minB, strideB,
      extentB, c, minC, strideC, extentC, d, minD, strideD, extentD)
    res2 := lemmaNonlinear(tid, e - minE, strideE, extentE)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}