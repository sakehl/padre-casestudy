domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 0
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 0
  requires subtype2 >= 0
  requires subtype2 <= 0
  decreases 
{
  (subtype1 == 0 ==> true) && true
}

predicate test(i: Int) {
  0 < i
}

method main(tid: Int) returns (res: Void)
{
  {
    var exc: Ref
    var return: Void
    var i: Int
    var flatten: Int
    var flatten1: Int
    var excbeforeloop: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    flatten := 0
    i := flatten
    while (i < 10)
      invariant exc == excbeforeloop
      invariant 0 <= i
      invariant i < 10 + 1
      invariant (forall j: Int ::
          { acc(test(j), write) }
          0 <= j && j < i + 1 ==> acc(test(j), write)) 
    {
      fold acc(test(i), write)
      flatten1 := i
      i := i + 1
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}