domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Array  {
  
  function array_loc(a: Array, i: Int): Ref 
  
  function alen(a: Array): Int 
  
  function loc_inv_1(loc: Ref): Array 
  
  function loc_inv_2(loc: Ref): Int 
  
  axiom {
    (forall a: Array, i: Int ::
      { array_loc(a, i) }
      loc_inv_1(array_loc(a, i)) == a && loc_inv_2(array_loc(a, i)) == i)
  }
  
  axiom {
    (forall a: Array :: { alen(a) } alen(a) >= 0)
  }
}

domain Any  {
  
  
}

domain Option[T1]  {
  
  function none1(): Option[T1] 
  
  function some(x: T1): Option[T1] 
  
  function option_get(opt: Option[T1]): T1 
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (none1(): Option[T1]) != (some(x): Option[T1]))
  }
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (option_get((some(x): Option[T1])): T1) == x)
  }
  
  axiom {
    (forall opt: Option[T1] ::
      { (some((option_get(opt): T1)): Option[T1]) }
      (some((option_get(opt): T1)): Option[T1]) == opt)
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

field rat: Perm

field int: Int

function aloc(a: Array, i: Int): Ref
  requires 0 <= i
  requires i < alen(a)
  decreases 
  ensures loc_inv_1(result) == a
  ensures loc_inv_2(result) == i
{
  array_loc(a, i)
}

function anyAs(t: Any): Any
  decreases 


function asAny(t: Any): Any
  decreases 
  ensures anyAs(result) == t


function optGet(opt: Option[Any]): Any
  requires opt != (none1(): Option[Any])
  decreases 
  ensures (some(result): Option[Any]) == opt
{
  (option_get(opt): Any)
}

function optOrElse(opt: Option[Any], alt: Any): Any
  decreases 
  ensures opt == (none1(): Option[Any]) ==> result == alt
  ensures opt != (none1(): Option[Any]) ==> result == optGet(opt)
{
  (opt == (none1(): Option[Any]) ? alt : optGet(opt))
}

function optGet1(opt: Option[Array]): Array
  requires opt != (none1(): Option[Array])
  decreases 
  ensures (some(result): Option[Array]) == opt
{
  (option_get(opt): Array)
}

function lemmaNonlinear(a: Int, b: Int, maxA: Int): Bool
  requires 0 <= a
  requires 0 < b
  requires a < maxA
  decreases b
  ensures 0 <= a * b
  ensures a * b < (maxA - 1) * b + 1
  ensures result
{
  (1 < b ? lemmaNonlinear(a, b - 1, maxA) : true)
}

function lemma2dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int): Bool
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires 0 < strideA
  requires 0 < strideB
  requires extentA * strideA <= strideB
  decreases 
  ensures 0 <= (a - minA) * strideA + (b - minB) * strideB
  ensures (a - minA) * strideA + (b - minB) * strideB < strideB * extentB
  ensures result
{
  lemmaNonlinear(a - minA, strideA, extentA) &&
  lemmaNonlinear(b - minB, strideB, extentB)
}

function lemma3dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int, extentC: Int): Bool
  requires (let a1 ==
      (a) in
      (let minA1 ==
        (minA) in
        (let strideA1 ==
          (strideA) in
          (let extentA1 ==
            (extentA) in
            (let b1 ==
              (b) in
              (let minB1 ==
                (minB) in
                (let strideB1 ==
                  (strideB) in
                  (let extentB1 ==
                    (extentB) in
                    (let c1 ==
                      (c) in
                      (let minC1 ==
                        (minC) in
                        (let strideC1 ==
                          (strideC) in
                          (let extentC1 ==
                            (extentC) in
                            minA1 <= a1 && a1 - minA1 < extentA1 &&
                            minB1 <= b1 &&
                            b1 - minB1 < extentB1 &&
                            minC1 <= c1 &&
                            c1 - minC1 < extentC1 &&
                            0 < strideA1 &&
                            0 < strideB1 &&
                            0 < strideC1 &&
                            extentA1 * strideA1 <= strideB1 &&
                            extentB1 * strideB1 <= strideC1))))))))))))
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC <
    strideC * extentC
  ensures result
{
  lemma2dAccess(a, minA, strideA, extentA, b, minB, strideB, extentB) &&
  lemmaNonlinear(c - minC, strideC, extentC)
}

function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 0
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 0
  requires subtype2 >= 0
  requires subtype2 <= 0
  decreases 
{
  (subtype1 == 0 ==> true) && true
}

predicate fR(x: Int, xMin: Int, xExtent: Int, xStride: Int, y: Int, yMin: Int,
  yExtent: Int, yStride: Int, f: Option[Array]) {
  f != (none1(): Option[Array]) && alen(optGet1(f)) == yStride * yStride &&
  xMin <= x &&
  x - xMin < xExtent &&
  yMin <= y &&
  y - yMin < yExtent &&
  0 < xStride &&
  xExtent * xStride <= yStride &&
  lemma2dAccess(x, xMin, xStride, xExtent, y, yMin, yStride, yExtent) &&
  (let i ==
    ((x - xMin) * xStride + (y - yMin) * yStride) in
    0 <= i && i < alen(optGet1(f)) && acc(aloc(optGet1(f), i).int, write))
}

predicate denominatorR(a: Int, aMin: Int, aExtent: Int, aStride: Int, si: Int,
  siMin: Int, siExtent: Int, siStride: Int, i: Int, iMin: Int, iExtent: Int,
  iStride: Int, data: Option[Array]) {
  data != (none1(): Option[Array]) &&
  alen(optGet1(data)) == aStride * aExtent &&
  (let a1 ==
    (i) in
    (let minA ==
      (iMin) in
      (let strideA ==
        (iStride) in
        (let extentA ==
          (iExtent) in
          (let b ==
            (si) in
            (let minB ==
              (siMin) in
              (let strideB ==
                (siStride) in
                (let extentB ==
                  (siExtent) in
                  (let c ==
                    (a) in
                    (let minC ==
                      (aMin) in
                      (let strideC ==
                        (aStride) in
                        (let extentC ==
                          (aExtent) in
                          minA <= a1 && a1 - minA < extentA && minB <= b &&
                          b - minB < extentB &&
                          minC <= c &&
                          c - minC < extentC &&
                          0 < strideA &&
                          0 < strideB &&
                          0 < strideC &&
                          extentA * strideA <= strideB &&
                          extentB * strideB <= strideC)))))))))))) &&
  lemma3dAccess(i, iMin, iStride, iExtent, si, siMin, siStride, siExtent, a,
  aMin, aStride, aExtent) &&
  (let i1 ==
    ((a - aMin) * aStride + (si - siMin) * siStride + (i - iMin) * iStride) in
    0 <= i1 && i1 < alen(optGet1(data)) &&
    acc(aloc(optGet1(data), i1).rat, write))
}

method foldDenominatorR(tid: Int, aExtent: Int, siExtent: Int, iExtent: Int,
  aStride: Int, data: Option[Array])
  returns (res: Void)
  requires 0 < aExtent
  requires 0 < siExtent
  requires 0 < iExtent
  requires aStride == siExtent * iExtent
  requires data != (none1(): Option[Array])
  requires alen(optGet1(data)) == aStride * aExtent
  requires (forall j: Int ::
      { aloc(optGet1(data), j) }
      0 <= j && j < alen(optGet1(data)) ==>
      acc(aloc(optGet1(data), j).rat, write))
  ensures 0 < aExtent
  ensures 0 < siExtent
  ensures 0 < iExtent
  ensures aStride == siExtent * iExtent
  ensures data != (none1(): Option[Array])
  ensures alen(optGet1(data)) == aStride * aExtent
  ensures (forall a: Int, si: Int, i: Int ::
      { denominatorR(a, 0, aExtent, aStride, si, 0, siExtent, iExtent, i, 0,
      iExtent, 1, data) }
      0 <= a && a < aExtent && 0 <= si && si < siExtent && 0 <= i &&
      i < iExtent ==>
      acc(denominatorR(a, 0, aExtent, aStride, si, 0, siExtent, iExtent, i,
      0, iExtent, 1, data), write))
{
  {
    var exc: Ref
    var return: Void
    var a0: Int
    var si0: Int
    var i0: Int
    var flatten: Int
    var flatten1: Int
    var flatten2: Int
    var flatten3: Int
    var flatten4: Int
    var flatten5: Int
    var excbeforeloop: Ref
    var excbeforeloop1: Ref
    var excbeforeloop2: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    flatten := 0
    a0 := flatten
    while (a0 < aExtent)
      invariant exc == excbeforeloop
      invariant 0 < aExtent
      invariant 0 < siExtent
      invariant 0 < iExtent
      invariant aStride == siExtent * iExtent
      invariant data != (none1(): Option[Array])
      invariant alen(optGet1(data)) == aStride * aExtent
      invariant 0 <= a0
      invariant a0 < aExtent + 1
      invariant (forall a: Int, si: Int, i: Int ::
          { denominatorR(a, 0, aExtent, aStride, si, 0, siExtent, iExtent, i,
          0, iExtent, 1, data) }
          0 <= a && a < a0 && 0 <= si && si < siExtent && 0 <= i &&
          i < iExtent ==>
          acc(denominatorR(a, 0, aExtent, aStride, si, 0, siExtent, iExtent,
          i, 0, iExtent, 1, data), write))
      invariant (forall i_si_a: Int ::
          { aloc(optGet1(data), i_si_a) }
          0 <= (i_si_a - aStride * a0) / aStride + a0 &&
          0 <= i_si_a - aStride * a0 &&
          i_si_a - aStride * a0 < aStride * (aExtent - a0) &&
          i_si_a < alen(optGet1(data)) ==>
          acc(aloc(optGet1(data), i_si_a).rat, write)) 
    {
      label LOOP1
      excbeforeloop1 := exc
      flatten2 := 0
      si0 := flatten2
      while (si0 < siExtent)
        invariant exc == excbeforeloop1
        invariant 0 < aExtent
        invariant 0 < siExtent
        invariant 0 < iExtent
        invariant aStride == siExtent * iExtent
        invariant data != (none1(): Option[Array])
        invariant alen(optGet1(data)) == aStride * aExtent
        invariant 0 <= si0
        invariant si0 < siExtent + 1
        invariant (forall si: Int, i: Int ::
            { denominatorR(a0, 0, aExtent, aStride, si, 0, siExtent, iExtent,
            i, 0, iExtent, 1, data) }
            0 <= si && si < si0 && 0 <= i && i < iExtent ==>
            acc(denominatorR(a0, 0, aExtent, aStride, si, 0, siExtent, iExtent,
            i, 0, iExtent, 1, data), write))
        invariant (forall i_si: Int ::
            { aloc(optGet1(data), i_si) }
            0 <= i_si - (a0 * aStride + iExtent * si0) &&
            i_si - (a0 * aStride + iExtent * si0) <
            iExtent * (siExtent - si0) &&
            lemmaNonlinear(a0, aStride, aExtent) &&
            i_si < alen(optGet1(data)) ==>
            acc(aloc(optGet1(data), i_si).rat, write)) 
      {
        label LOOP2
        excbeforeloop2 := exc
        flatten4 := 0
        i0 := flatten4
        while (i0 < iExtent)
          invariant exc == excbeforeloop2
          invariant 0 < aExtent
          invariant 0 < siExtent
          invariant 0 < iExtent
          invariant aStride == siExtent * iExtent
          invariant data != (none1(): Option[Array])
          invariant alen(optGet1(data)) == aStride * aExtent
          invariant 0 <= i0
          invariant i0 < iExtent + 1
          invariant 0 <= a0
          invariant a0 < aExtent
          invariant (forall i: Int ::
              { denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, iExtent,
              i, 0, iExtent, 1, data) }
              0 <= i && i < i0 ==>
              acc(denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, iExtent,
              i, 0, iExtent, 1, data), write))
          invariant (forall i: Int ::
              { aloc(optGet1(data), i) }
              i - (a0 * aStride + si0 * iExtent + i0) + i0 <
              alen(optGet1(data)) - (a0 * aStride + si0 * iExtent) &&
              0 <= i - (a0 * aStride + si0 * iExtent + i0) &&
              i - (a0 * aStride + si0 * iExtent + i0) < iExtent - i0 &&
              lemmaNonlinear(a0, aStride, aExtent) &&
              lemmaNonlinear(si0, iExtent, siExtent) ==>
              acc(aloc(optGet1(data), i).rat, write)) 
        {
          assert 0 <= i0 && i0 < iExtent
          assert lemma3dAccess(i0, 0, 1, iExtent, si0, 0, iExtent, siExtent,
            a0, 0, aStride, aExtent)
          fold acc(denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, iExtent,
            i0, 0, iExtent, 1, data), write)
          flatten5 := i0
          i0 := i0 + 1
        }
        flatten3 := si0
        si0 := si0 + 1
      }
      flatten1 := a0
      a0 := a0 + 1
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method foldDenominatorRI0(tid: Int, aExtent: Int, siExtent: Int, iExtent: Int,
  siStride: Int, aStride: Int, data: Option[Array], si0: Int, a0: Int)
  returns (res: Void)
  requires 0 < aExtent
  requires 0 < siExtent
  requires 0 < iExtent
  requires aStride == siExtent * siStride
  requires siStride == iExtent
  requires data != (none1(): Option[Array])
  requires alen(optGet1(data)) == aStride * aExtent
  requires 0 <= si0
  requires si0 < siExtent
  requires 0 <= a0
  requires a0 < aExtent
  requires (forall i_si: Int ::
      { aloc(optGet1(data), i_si) }
      0 <= i_si - (a0 * aStride + siStride * si0) &&
      i_si - (a0 * aStride + siStride * si0) < siStride * (siExtent - si0) &&
      i_si < alen(optGet1(data)) ==>
      acc(aloc(optGet1(data), i_si).rat, write))
  ensures 0 < aExtent
  ensures 0 < siExtent
  ensures 0 < iExtent
  ensures aStride == siExtent * siStride
  ensures siStride == iExtent
  ensures data != (none1(): Option[Array])
  ensures alen(optGet1(data)) == aStride * aExtent
  ensures 0 <= si0
  ensures si0 < siExtent
  ensures 0 <= a0
  ensures a0 < aExtent
  ensures (forall i: Int ::
      { denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, siStride, i,
      0, iExtent, 1, data) }
      0 <= i && i < iExtent ==>
      acc(denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, siStride,
      i, 0, iExtent, 1, data), write))
  ensures (forall i_si: Int ::
      { aloc(optGet1(data), i_si) }
      0 <= i_si - (a0 * aStride + siStride * (si0 + 1)) &&
      i_si - (a0 * aStride + siStride * (si0 + 1)) <
      siStride * (-1 + (siExtent - si0)) &&
      i_si < alen(optGet1(data)) ==>
      acc(aloc(optGet1(data), i_si).rat, write))
{
  {
    var exc: Ref
    var return: Void
    var i0: Int
    var flatten: Int
    var flatten1: Int
    var excbeforeloop: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    flatten := 0
    i0 := flatten
    while (i0 < iExtent)
      invariant exc == excbeforeloop
      invariant 0 < aExtent
      invariant 0 < siExtent
      invariant 0 < iExtent
      invariant aStride == siExtent * siStride
      invariant siStride == iExtent
      invariant data != (none1(): Option[Array])
      invariant alen(optGet1(data)) == aStride * aExtent
      invariant 0 <= si0
      invariant si0 < siExtent
      invariant 0 <= a0
      invariant a0 < aExtent
      invariant 0 <= i0
      invariant i0 < iExtent + 1
      invariant 0 <= a0
      invariant a0 < aExtent
      invariant (forall i: Int ::
          { denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, siStride,
          i, 0, iExtent, 1, data) }
          0 <= i && i < i0 ==>
          acc(denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, siStride,
          i, 0, iExtent, 1, data), write))
      invariant (forall i: Int ::
          { aloc(optGet1(data), i) }
          i - (a0 * aStride + si0 * siStride + i0) + i0 <
          alen(optGet1(data)) - (a0 * aStride + si0 * siStride) &&
          0 <= i - (a0 * aStride + si0 * siStride + i0) &&
          i - (a0 * aStride + si0 * siStride + i0) < iExtent - i0 &&
          lemmaNonlinear(si0, iExtent, siExtent) ==>
          acc(aloc(optGet1(data), i).rat, write)) 
    {
      assert 0 <= i0 && i0 < iExtent
      assert lemma3dAccess(i0, 0, 1, iExtent, si0, 0, siStride, siExtent, a0,
        0, aStride, aExtent)
      fold acc(denominatorR(a0, 0, aExtent, aStride, si0, 0, siExtent, siStride,
        i0, 0, iExtent, 1, data), write)
      flatten1 := i0
      i0 := i0 + 1
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}