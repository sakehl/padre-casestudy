
/* MACHINE GENERATED By Halide. */

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#ifndef HALIVER_GLOBALS
#define HALIVER_GLOBALS

struct halide_dimension_t {
    int32_t min, extent, stride;
    uint32_t flags;
};

inline void halide_unused(bool e){};

/*@
pure int max(int x, int y) = x > y ? x : y;

pure int min(int x, int y) = x > y ? y : x;

pure float max(float x, float y) = x > y ? x : y;

pure float min(float x, float y) = x > y ? y : x;

pure int abs(int x) = x >= 0 ? x : -x;

pure float abs(float x) = x >= 0 ? x : -x;

// Euclidean division is defined internally in VerCors
pure int hdiv(int x, int y) = y == 0 ? 0 : \euclidean_div(x, y);
pure int hmod(int x, int y) = y == 0 ? 0 : \euclidean_mod(x, y);
@*/

/*@
  requires y != 0;
  ensures \result == \euclidean_div(x, y);
@*/
inline int /*@ pure @*/ div_eucl(int x, int y)
{
    int q = x/y;
    int r = x%y;
    return r < 0 ? q + (y > 0 ? -1 : 1) : q;
}

/*@
  requires y != 0;
  ensures \result == \euclidean_mod(x, y);
@*/
inline int /*@ pure @*/ mod_eucl(int x, int y)
{
    int r = x%y;
    return (x >= 0 || r == 0) ? r : r + abs(y);
}

static inline int /*@ pure @*/ min(int x, int y) {return x < y ? x : y;}
static inline float /*@ pure @*/ fast_inverse_f32(float x) {return 1.0f/x;}

static inline float /*@ pure @*/ sqrt_f32(float x) {return sqrtf(x);}
static inline float /*@ pure @*/ sin_f32(float x) {return sinf(x);}
static inline float /*@ pure @*/ asin_f32(float x) {return asinf(x);}
static inline float /*@ pure @*/ cos_f32(float x) {return cosf(x);}
static inline float /*@ pure @*/ acos_f32(float x) {return acosf(x);}
static inline float /*@ pure @*/ tan_f32(float x) {return tanf(x);}
static inline float /*@ pure @*/ atan_f32(float x) {return atanf(x);}
static inline float /*@ pure @*/ atan2_f32(float x, float y) {return atan2f(x, y);}
static inline float /*@ pure @*/ sinh_f32(float x) {return sinhf(x);}
static inline float /*@ pure @*/ cosh_f32(float x) {return coshf(x);}
static inline float /*@ pure @*/ tanh_f32(float x) {return tanhf(x);}
static inline float /*@ pure @*/ hypot_f32(float x, float y) {return hypotf(x, y);}
static inline float /*@ pure @*/ exp_f32(float x) {return expf(x);}
static inline float /*@ pure @*/ log_f32(float x) {return logf(x);}
static inline float /*@ pure @*/ pow_f32(float x, float y) {return powf(x, y);}
static inline float /*@ pure @*/ floor_f32(float x) {return floorf(x);}
static inline float /*@ pure @*/ ceil_f32(float x) {return ceilf(x);}
static inline float /*@ pure @*/ round_f32(float x) {return roundf(x);}

static inline double /*@ pure @*/ sqrt_f64(double x) {return sqrt(x);}
static inline double /*@ pure @*/ sin_f64(double x) {return sin(x);}
static inline double /*@ pure @*/ asin_f64(double x) {return asin(x);}
static inline double /*@ pure @*/ cos_f64(double x) {return cos(x);}
static inline double /*@ pure @*/ acos_f64(double x) {return acos(x);}
static inline double /*@ pure @*/ tan_f64(double x) {return tan(x);}
static inline double /*@ pure @*/ atan_f64(double x) {return atan(x);}
static inline double /*@ pure @*/ atan2_f64(double x, double y) {return atan2(x, y);}
static inline double /*@ pure @*/ sinh_f64(double x) {return sinh(x);}
static inline double /*@ pure @*/ cosh_f64(double x) {return cosh(x);}
static inline double /*@ pure @*/ tanh_f64(double x) {return tanh(x);}
static inline double /*@ pure @*/ hypot_f64(double x, double y) {return hypot(x, y);}
static inline double /*@ pure @*/ exp_f64(double x) {return exp(x);}
static inline double /*@ pure @*/ log_f64(double x) {return log(x);}
static inline double /*@ pure @*/ pow_f64(double x, double y) {return pow(x, y);}
static inline double /*@ pure @*/ floor_f64(double x) {return floor(x);}
static inline double /*@ pure @*/ ceil_f64(double x) {return ceil(x);}
static inline double /*@ pure @*/ round_f64(double x) {return round(x);}

//inline float nan_f32() {return NAN;}
inline float nan_f32() {return 0.0f;}
/*@
inline resource dim_perm(struct halide_dimension_t *dim, rational p, int i) = 
 Perm(&dim[i], 1\2) **
 Perm(dim[i].min, 1\2) **
 Perm(dim[i].stride, 1\2) **
 Perm(dim[i].extent, 1\2) **
 dim[i].extent > 0
 ;
 
 requires a >= 0;
 requires b > 0;
 requires a < max_a;
 ensures a*b <= (max_a-1)*b;
 ensures \result;
 decreases b;
pure bool lemma_nonlinear(int a, int b, int max_a);// = b>1 ? lemma_nonlinear(a, b-1, max_a) : true;
 
 requires a-min_a >= 0 && a-min_a<extent_a;
 requires b-min_b >= 0 && b-min_b<extent_b;
 requires stride_a > 0;
 requires stride_b >= extent_a*stride_a;

 ensures 0 <= (b-min_b)*stride_b;
 ensures 0 <= (a-min_a)*stride_a + (b-min_b)*stride_b;
 ensures (a-min_a)*stride_a + (b-min_b)*stride_b < stride_b*extent_b;
 ensures \result;
 decreases;
pure bool lemma_2d_access(
 int a, int min_a, int stride_a, int extent_a,
 int b, int min_b, int stride_b, int extent_b);// = lemma_nonlinear(a-min_a, stride_a, extent_a) && lemma_nonlinear(b-min_b, stride_b, extent_b);

 requires a-min_a >= 0 && a-min_a < extent_a;
 requires b-min_b >= 0 && b-min_b < extent_b;
 requires c-min_c >= 0 && c-min_c < extent_c;
 requires stride_a > 0;
 requires stride_b >= extent_a * stride_a;
 requires stride_c >= extent_b * stride_b;
 
 ensures 0 <= (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c;
 ensures (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c < stride_c * extent_c;
 ensures \result;
 decreases;
pure bool lemma_3d_access(
  int a, int min_a, int stride_a, int extent_a,
  int b, int min_b, int stride_b, int extent_b,
  int c, int min_c, int stride_c, int extent_c
);// = lemma_2d_access(a, min_a, stride_a, extent_a, b, min_b, stride_b, extent_b) && lemma_nonlinear(c-min_c, stride_c, extent_c);


 requires a-min_a >= 0 && a-min_a < extent_a;
 requires b-min_b >= 0 && b-min_b < extent_b;
 requires c-min_c >= 0 && c-min_c < extent_c;
 requires d-min_d >= 0 && d-min_d < extent_d;
 requires stride_a > 0;
 requires stride_b >= extent_a * stride_a;
 requires stride_c >= extent_b * stride_b;
 requires stride_d >= extent_c * stride_c;

 ensures 0 <= (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d;
 ensures (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d < stride_d * extent_d;
 ensures \result;
 decreases;
pure bool lemma_4d_access(
  int a, int min_a, int stride_a, int extent_a,
  int b, int min_b, int stride_b, int extent_b,
  int c, int min_c, int stride_c, int extent_c,
  int d, int min_d, int stride_d, int extent_d
);// = lemma_3d_access(a, min_a, stride_a, extent_a, b, min_b, stride_b, extent_b, c, min_c, stride_c, extent_c) && lemma_nonlinear(d-min_d, stride_d, extent_d);

 requires a-min_a >= 0 && a-min_a < extent_a;
 requires b-min_b >= 0 && b-min_b < extent_b;
 requires c-min_c >= 0 && c-min_c < extent_c;
 requires d-min_d >= 0 && d-min_d < extent_d;
 requires e-min_e >= 0 && e-min_e < extent_e;
 requires stride_a > 0;
 requires stride_b >= extent_a * stride_a;
 requires stride_c >= extent_b * stride_b;
 requires stride_d >= extent_c * stride_c;
 requires stride_e >= extent_d * stride_d;

 ensures 0 <= (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d + (e-min_e) * stride_e;
 ensures (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d + (e-min_e) * stride_e < stride_e * extent_e;
 ensures \result;
 decreases;
pure bool lemma_5d_access(
  int a, int min_a, int stride_a, int extent_a,
  int b, int min_b, int stride_b, int extent_b,
  int c, int min_c, int stride_c, int extent_c,
  int d, int min_d, int stride_d, int extent_d,
  int e, int min_e, int stride_e, int extent_e
);// = lemma_4d_access(a, min_a, stride_a, extent_a, b, min_b, stride_b, extent_b, c, min_c, stride_c, extent_c, d, min_d, stride_d, extent_d) && lemma_nonlinear(e-min_e, stride_e, extent_e);

pure int split(int xi, int xo, int xmin, int factor) = xo*factor + xi +xmin;
@*/
#endif // HALIVER_GLOBALS

/*@
resource distance_pred(
 double* data
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data != NULL && \pointer_length(data) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:distance_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_distance(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:distance_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_distance(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource _float64_pred(double* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );

resource next_sol_0_pred(
 double* data_0
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_0 != NULL && \pointer_length(data_0) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_sol_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_next_sol_0(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_sol_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_next_sol_0(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource next_sol_1_pred(
 double* data_1
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_1 != NULL && \pointer_length(data_1) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_sol_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_next_sol_1(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_sol_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_next_sol_1(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource next_sol__im_pred(
 double* data
 , int _0, int _0_min, int _0_extent, int _1, int _1_min, int _1_extent, int _2, int _2_min, int _2_extent, int _3, int _3_min, int _3_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  _1 >= _1_min && _1 < _1_min + _1_extent && 
  _2 >= _2_min && _2 < _2_min + _2_extent && 
  _3 >= _3_min && _3 < _3_min + _3_extent && 
  data != NULL && \pointer_length(data) == _0_extent * _1_extent * _2_extent * _3_extent && lemma_4d_access(_0, _0_min, 1, _0_extent, _1, _1_min, _0_extent, _1_extent, _2, _2_min, _0_extent * _1_extent, _2_extent, _3, _3_min, _0_extent * _1_extent * _2_extent, _3_extent)) ** 
  (\let int idx = (_0-_0_min)*1 + (_1-_1_min)*_0_extent + (_2-_2_min)*_0_extent * _1_extent + (_3-_3_min)*_0_extent * _1_extent * _2_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:next_sol__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
void from_pred_next_sol__im(double* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:next_sol__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
void to_pred_next_sol__im(double* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

resource next_solutions__1_pred(
 double* data
 , int c, int c_min, int c_extent, int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( c >= c_min && c < c_min + c_extent && 
  i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data != NULL && \pointer_length(data) == c_extent * i_extent * si_extent * a_extent && lemma_4d_access(c, c_min, 1, c_extent, i, i_min, c_extent, i_extent, si, si_min, c_extent * i_extent, si_extent, a, a_min, c_extent * i_extent * si_extent, a_extent)) ** 
  (\let int idx = (c-c_min)*1 + (i-i_min)*c_extent + (si-si_min)*c_extent * i_extent + (a-a_min)*c_extent * i_extent * si_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _c_extent > 0 && _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _c_extent*_i_extent*_si_extent*_a_extent;
 requires (\forall* int _c, int _i, int _si, int _a; _c >= _c_min && _c < _c_min + _c_extent && _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_solutions__1_pred(_xs, _c, _c_min, _c_extent, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _c_extent*_i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_next_solutions__1(double* _xs, int _c_min, int _c_extent, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _c_extent > 0 && _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _c_extent*_i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _c_extent*_i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _c, int _i, int _si, int _a; _c >= _c_min && _c < _c_min + _c_extent && _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_solutions__1_pred(_xs, _c, _c_min, _c_extent, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_next_solutions__1(double* _xs, int _c_min, int _c_extent, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource next_solutions_0_0_pred(
 double* data_0
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_0 != NULL && \pointer_length(data_0) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_solutions_0_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_next_solutions_0_0(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_solutions_0_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_next_solutions_0_0(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource next_solutions_0_1_pred(
 double* data_1
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_1 != NULL && \pointer_length(data_1) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_solutions_0_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_next_solutions_0_1(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:next_solutions_0_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_next_solutions_0_1(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource solD_0_pred(
 double* data_0
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_0 != NULL && \pointer_length(data_0) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solD_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_solD_0(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solD_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_solD_0(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource solD_1_pred(
 double* data_1
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_1 != NULL && \pointer_length(data_1) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solD_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_solD_1(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solD_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_solD_1(double* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource sol__im_pred(
 double* data
 , int _0, int _0_min, int _0_extent, int _1, int _1_min, int _1_extent, int _2, int _2_min, int _2_extent, int _3, int _3_min, int _3_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  _1 >= _1_min && _1 < _1_min + _1_extent && 
  _2 >= _2_min && _2 < _2_min + _2_extent && 
  _3 >= _3_min && _3 < _3_min + _3_extent && 
  data != NULL && \pointer_length(data) == _0_extent * _1_extent * _2_extent * _3_extent && lemma_4d_access(_0, _0_min, 1, _0_extent, _1, _1_min, _0_extent, _1_extent, _2, _2_min, _0_extent * _1_extent, _2_extent, _3, _3_min, _0_extent * _1_extent * _2_extent, _3_extent)) ** 
  (\let int idx = (_0-_0_min)*1 + (_1-_1_min)*_0_extent + (_2-_2_min)*_0_extent * _1_extent + (_3-_3_min)*_0_extent * _1_extent * _2_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:sol__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
void from_pred_sol__im(double* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:sol__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
void to_pred_sol__im(double* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

resource _int32_pred(int* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );

resource _uint1_pred(bool* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );


@*/
#ifndef HALIDE_BUFFER_TYPE_DOUBLE
#define HALIDE_BUFFER_TYPE_DOUBLE
struct halide_buffer_double {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    double *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline double *_halide_buffer_get_host_double(struct halide_buffer_double *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_double(struct halide_buffer_double *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_DOUBLE
//@ pure float pure_sol_(int x);
//@ pure float pure_next_sol_(int x);
//@ pure float pure_next_solutions__1(int x);



#ifdef __cplusplus
extern "C" {
#endif

/*@
 context buffer_double(_sol__buffer, 1\2, 4);
 context dim_perm(_sol__buffer->dim, 1\2, 0);
 context dim_perm(_sol__buffer->dim, 1\2, 1);
 context dim_perm(_sol__buffer->dim, 1\2, 2);
 context dim_perm(_sol__buffer->dim, 1\2, 3);
 context \pointer_length(_sol__buffer->host) == _sol__buffer->dim[3].extent * _sol__buffer->dim[3].stride;
 context buffer_double(_next_sol__buffer, 1\2, 4);
 context dim_perm(_next_sol__buffer->dim, 1\2, 0);
 context dim_perm(_next_sol__buffer->dim, 1\2, 1);
 context dim_perm(_next_sol__buffer->dim, 1\2, 2);
 context dim_perm(_next_sol__buffer->dim, 1\2, 3);
 context \pointer_length(_next_sol__buffer->host) == _next_sol__buffer->dim[3].extent * _next_sol__buffer->dim[3].stride;
 context buffer_double(_next_solutions__1_buffer, 1\2, 4);
 context dim_perm(_next_solutions__1_buffer->dim, 1\2, 0);
 context dim_perm(_next_solutions__1_buffer->dim, 1\2, 1);
 context dim_perm(_next_solutions__1_buffer->dim, 1\2, 2);
 context dim_perm(_next_solutions__1_buffer->dim, 1\2, 3);
 context \pointer_length(_next_solutions__1_buffer->host) == _next_solutions__1_buffer->dim[3].extent * _next_solutions__1_buffer->dim[3].stride;
 context _next_sol__buffer->host != _sol__buffer->host;
 context _next_solutions__1_buffer->host != _sol__buffer->host;
 context _next_solutions__1_buffer->host != _next_sol__buffer->host;
 context _next_sol__buffer->dim[0].min == 0 && _next_sol__buffer->dim[0].extent == 2 && _next_sol__buffer->dim[0].stride == 1;
 context _next_sol__buffer->dim[1].min == 0 && _next_sol__buffer->dim[1].extent == 2 && _next_sol__buffer->dim[1].stride == 2;
 context _next_sol__buffer->dim[2].min == 0 && _next_sol__buffer->dim[2].extent == _n_solutions && _next_sol__buffer->dim[2].stride == 4;
 context _next_sol__buffer->dim[3].min == 0 && _next_sol__buffer->dim[3].extent == _n_antennas && _next_sol__buffer->dim[3].stride == _n_solutions*4;
 context [1\2]_float64_pred(_next_sol__buffer->host);
 context _sol__buffer->dim[0].min == 0 && _sol__buffer->dim[0].extent == 2 && _sol__buffer->dim[0].stride == 1;
 context _sol__buffer->dim[1].min == 0 && _sol__buffer->dim[1].extent == 2 && _sol__buffer->dim[1].stride == 2;
 context _sol__buffer->dim[2].min == 0 && _sol__buffer->dim[2].extent == _n_solutions && _sol__buffer->dim[2].stride == 4;
 context _sol__buffer->dim[3].min == 0 && _sol__buffer->dim[3].extent == _n_antennas && _sol__buffer->dim[3].stride == _n_solutions*4;
 context [1\2]_float64_pred(_sol__buffer->host);
 context _next_solutions__1_buffer->dim[0].min == 0 && _next_solutions__1_buffer->dim[0].extent == 2 && _next_solutions__1_buffer->dim[0].stride == 1;
 context _next_solutions__1_buffer->dim[1].min == 0 && _next_solutions__1_buffer->dim[1].extent == 2 && _next_solutions__1_buffer->dim[1].stride == 2;
 context _next_solutions__1_buffer->dim[2].min == 0 && _next_solutions__1_buffer->dim[2].extent == _n_solutions && _next_solutions__1_buffer->dim[2].stride == 4;
 context _next_solutions__1_buffer->dim[3].min == 0 && _next_solutions__1_buffer->dim[3].extent == _n_antennas && _next_solutions__1_buffer->dim[3].stride == _n_solutions*4;
 context (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; {:next_solutions__1_pred(_next_solutions__1_buffer->host, _0, 0, 2, _1, 0, 2, _2, 0, _n_solutions, _3, 0, _n_antennas):});
 context 0 < min(min(_n_antennas, _n_vis), _n_solutions);
 context_everywhere _n_antennas == 50;
 context_everywhere _n_solutions == 8;
 context_everywhere _n_vis == 230930;
@*/
int StepHalide(int32_t _n_vis, int32_t _n_solutions, int32_t _n_antennas, bool _phase_only, double _step_size, struct halide_buffer_double *_sol__buffer, struct halide_buffer_double *_next_sol__buffer, struct halide_buffer_double *_next_solutions__1_buffer) {
 double* _next_sol_ = _halide_buffer_get_host_double(_next_sol__buffer);
 int32_t _next_sol__min_0 = _halide_buffer_get_min_double(_next_sol__buffer, 0);
 int32_t _next_sol__extent_0 = _halide_buffer_get_extent_double(_next_sol__buffer, 0);
 int32_t _next_sol__stride_0 = _halide_buffer_get_stride_double(_next_sol__buffer, 0);
 int32_t _next_sol__min_1 = _halide_buffer_get_min_double(_next_sol__buffer, 1);
 int32_t _next_sol__extent_1 = _halide_buffer_get_extent_double(_next_sol__buffer, 1);
 int32_t _next_sol__stride_1 = _halide_buffer_get_stride_double(_next_sol__buffer, 1);
 int32_t _next_sol__min_2 = _halide_buffer_get_min_double(_next_sol__buffer, 2);
 int32_t _next_sol__extent_2 = _halide_buffer_get_extent_double(_next_sol__buffer, 2);
 int32_t _next_sol__stride_2 = _halide_buffer_get_stride_double(_next_sol__buffer, 2);
 int32_t _next_sol__min_3 = _halide_buffer_get_min_double(_next_sol__buffer, 3);
 int32_t _next_sol__extent_3 = _halide_buffer_get_extent_double(_next_sol__buffer, 3);
 int32_t _next_sol__stride_3 = _halide_buffer_get_stride_double(_next_sol__buffer, 3);
 double* _next_solutions__1 = _halide_buffer_get_host_double(_next_solutions__1_buffer);
 int32_t _next_solutions__1_min_0 = _halide_buffer_get_min_double(_next_solutions__1_buffer, 0);
 int32_t _next_solutions__1_extent_0 = _halide_buffer_get_extent_double(_next_solutions__1_buffer, 0);
 int32_t _next_solutions__1_stride_0 = _halide_buffer_get_stride_double(_next_solutions__1_buffer, 0);
 int32_t _next_solutions__1_min_1 = _halide_buffer_get_min_double(_next_solutions__1_buffer, 1);
 int32_t _next_solutions__1_extent_1 = _halide_buffer_get_extent_double(_next_solutions__1_buffer, 1);
 int32_t _next_solutions__1_stride_1 = _halide_buffer_get_stride_double(_next_solutions__1_buffer, 1);
 int32_t _next_solutions__1_min_2 = _halide_buffer_get_min_double(_next_solutions__1_buffer, 2);
 int32_t _next_solutions__1_extent_2 = _halide_buffer_get_extent_double(_next_solutions__1_buffer, 2);
 int32_t _next_solutions__1_stride_2 = _halide_buffer_get_stride_double(_next_solutions__1_buffer, 2);
 int32_t _next_solutions__1_min_3 = _halide_buffer_get_min_double(_next_solutions__1_buffer, 3);
 int32_t _next_solutions__1_extent_3 = _halide_buffer_get_extent_double(_next_solutions__1_buffer, 3);
 int32_t _next_solutions__1_stride_3 = _halide_buffer_get_stride_double(_next_solutions__1_buffer, 3);
 double* _sol_ = _halide_buffer_get_host_double(_sol__buffer);
 int32_t _sol__min_0 = _halide_buffer_get_min_double(_sol__buffer, 0);
 int32_t _sol__extent_0 = _halide_buffer_get_extent_double(_sol__buffer, 0);
 int32_t _sol__stride_0 = _halide_buffer_get_stride_double(_sol__buffer, 0);
 int32_t _sol__min_1 = _halide_buffer_get_min_double(_sol__buffer, 1);
 int32_t _sol__extent_1 = _halide_buffer_get_extent_double(_sol__buffer, 1);
 int32_t _sol__stride_1 = _halide_buffer_get_stride_double(_sol__buffer, 1);
 int32_t _sol__min_2 = _halide_buffer_get_min_double(_sol__buffer, 2);
 int32_t _sol__extent_2 = _halide_buffer_get_extent_double(_sol__buffer, 2);
 int32_t _sol__stride_2 = _halide_buffer_get_stride_double(_sol__buffer, 2);
 int32_t _sol__min_3 = _halide_buffer_get_min_double(_sol__buffer, 3);
 int32_t _sol__extent_3 = _halide_buffer_get_extent_double(_sol__buffer, 3);
 int32_t _sol__stride_3 = _halide_buffer_get_stride_double(_sol__buffer, 3);
 halide_unused((_next_sol__stride_0 == 1));
 halide_unused((_next_sol__min_0 == 0));
 halide_unused((_next_sol__extent_0 == 2));
 halide_unused((_next_sol__stride_1 == 2));
 halide_unused((_next_sol__min_1 == 0));
 halide_unused((_next_sol__extent_1 == 2));
 halide_unused((_next_sol__stride_2 == 4));
 halide_unused((_next_sol__min_2 == 0));
 halide_unused((_next_sol__extent_2 == _n_solutions));
 halide_unused((_next_sol__stride_3 == (_n_solutions * 4)));
 halide_unused((_next_sol__min_3 == 0));
 halide_unused((_next_sol__extent_3 == _n_antennas));
 halide_unused((_next_solutions__1_stride_0 == 1));
 halide_unused((_next_solutions__1_min_0 == 0));
 halide_unused((_next_solutions__1_extent_0 == 2));
 halide_unused((_next_solutions__1_stride_1 == 2));
 halide_unused((_next_solutions__1_min_1 == 0));
 halide_unused((_next_solutions__1_extent_1 == 2));
 halide_unused((_next_solutions__1_stride_2 == 4));
 halide_unused((_next_solutions__1_min_2 == 0));
 halide_unused((_next_solutions__1_extent_2 == _n_solutions));
 halide_unused((_next_solutions__1_stride_3 == (_n_solutions * 4)));
 halide_unused((_next_solutions__1_min_3 == 0));
 halide_unused((_next_solutions__1_extent_3 == _n_antennas));
 halide_unused((_sol__stride_0 == 1));
 halide_unused((_sol__min_0 == 0));
 halide_unused((_sol__extent_0 == 2));
 halide_unused((_sol__stride_1 == 2));
 halide_unused((_sol__min_1 == 0));
 halide_unused((_sol__extent_1 == 2));
 halide_unused((_sol__stride_2 == 4));
 halide_unused((_sol__min_2 == 0));
 halide_unused((_sol__extent_2 == _n_solutions));
 halide_unused((_sol__stride_3 == (_n_solutions * 4)));
 halide_unused((_sol__min_3 == 0));
 halide_unused((_sol__extent_3 == _n_antennas));
 // produce next_solutions$1
 /*@
  loop_invariant 0 <= _next_solutions__1_s0_a && _next_solutions__1_s0_a <= 0 + _n_antennas;
  loop_invariant [1\2]_float64_pred(_next_sol_);
  loop_invariant [1\2]_float64_pred(_sol_);
  loop_invariant (\forall* int _next_solutions__1_s0_a_forall, int _next_solutions__1_s0_si_forall, int _next_solutions__1_s0_i_forall, int _next_solutions__1_s0_c_forall; 0 <= _next_solutions__1_s0_a_forall && _next_solutions__1_s0_a_forall < _n_antennas && 0 <= _next_solutions__1_s0_si_forall && _next_solutions__1_s0_si_forall < _n_solutions && 0 <= _next_solutions__1_s0_i_forall && _next_solutions__1_s0_i_forall < 2 && 0 <= _next_solutions__1_s0_c_forall && _next_solutions__1_s0_c_forall < 2; {:next_solutions__1_pred(_next_solutions__1, _next_solutions__1_s0_c_forall, 0, 2, _next_solutions__1_s0_i_forall, 0, 2, _next_solutions__1_s0_si_forall, 0, _n_solutions, _next_solutions__1_s0_a_forall, 0, _n_antennas):});
 @*/
 for (int _next_solutions__1_s0_a = 0; _next_solutions__1_s0_a < 0 + _n_antennas; _next_solutions__1_s0_a++)
 {
  int32_t _t8045 = (_next_solutions__1_s0_a * _sol__stride_3);
  int32_t _t8048 = (_next_solutions__1_s0_a * _next_solutions__1_stride_3);
  int32_t _t8046 = (_next_sol__stride_3 * _next_solutions__1_s0_a);
  /*@
   loop_invariant 0 <= _next_solutions__1_s0_si && _next_solutions__1_s0_si <= 0 + _n_solutions;
   loop_invariant [1\2]_float64_pred(_next_sol_);
   loop_invariant [1\2]_float64_pred(_sol_);
   loop_invariant (\forall* int _next_solutions__1_s0_si_forall, int _next_solutions__1_s0_i_forall, int _next_solutions__1_s0_c_forall; 0 <= _next_solutions__1_s0_si_forall && _next_solutions__1_s0_si_forall < _n_solutions && 0 <= _next_solutions__1_s0_i_forall && _next_solutions__1_s0_i_forall < 2 && 0 <= _next_solutions__1_s0_c_forall && _next_solutions__1_s0_c_forall < 2; {:next_solutions__1_pred(_next_solutions__1, _next_solutions__1_s0_c_forall, 0, 2, _next_solutions__1_s0_i_forall, 0, 2, _next_solutions__1_s0_si_forall, 0, _n_solutions, _next_solutions__1_s0_a, 0, _n_antennas):});
  @*/
  for (int _next_solutions__1_s0_si = 0; _next_solutions__1_s0_si < 0 + _n_solutions; _next_solutions__1_s0_si++)
  {
   int32_t _t8049 = (_next_solutions__1_s0_si * 2);
   /*@
    loop_invariant 0 <= _next_solutions__1_s0_i && _next_solutions__1_s0_i <= 0 + 2;
    loop_invariant [1\2]_float64_pred(_next_sol_);
    loop_invariant [1\2]_float64_pred(_sol_);
    loop_invariant (\forall* int _next_solutions__1_s0_i_forall, int _next_solutions__1_s0_c_forall; 0 <= _next_solutions__1_s0_i_forall && _next_solutions__1_s0_i_forall < 2 && 0 <= _next_solutions__1_s0_c_forall && _next_solutions__1_s0_c_forall < 2; {:next_solutions__1_pred(_next_solutions__1, _next_solutions__1_s0_c_forall, 0, 2, _next_solutions__1_s0_i_forall, 0, 2, _next_solutions__1_s0_si, 0, _n_solutions, _next_solutions__1_s0_a, 0, _n_antennas):});
   @*/
   for (int _next_solutions__1_s0_i = 0; _next_solutions__1_s0_i < 0 + 2; _next_solutions__1_s0_i++)
   {
    {
     double _distance[1];
     /*@ ghost to_pred_distance(_distance, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, 1);
      @*/
     // produce distance
     int32_t _t8036 = (_next_solutions__1_s0_i + _t8049);
     int32_t _t8037 = ((_t8036 * 2) + _t8045);
     int32_t _t8038 = ((_t8036 * 2) + _t8046);
     double _725 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert (_t8037 + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[(_t8037 + 1)]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _726 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert _t8037 == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[_t8037]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _727 = 
     /*@ with
      unfold [1\2]_float64_pred(_next_sol_);
      assert (_t8038 + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_next_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _next_sol__stride_3, _n_antennas); @*/
      _next_sol_[(_t8038 + 1)]
     /*@ then
      fold [1\2]_float64_pred(_next_sol_); @*/
     ;
     double _728 = 
     /*@ with
      unfold [1\2]_float64_pred(_next_sol_);
      assert _t8038 == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_next_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _next_sol__stride_3, _n_antennas); @*/
      _next_sol_[_t8038]
     /*@ then
      fold [1\2]_float64_pred(_next_sol_); @*/
     ;
     /*@
      unfold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     _distance[0]= (atan2_f64(_725, _726) - atan2_f64(_727, _728));
     /*@ fold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     double _729 = 
     /*@ with
      unfold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
      _distance[0]
     /*@ then
      fold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     ;
     double _t8025 = _729;
     /*@
      unfold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     _distance[0]= (((3.141593 < _t8025) ? -6.283185 : 6.283185) + _t8025);
     /*@ fold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     // consume distance
     double _730 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert (((_next_solutions__1_s0_i + _t8049) * 2) + _t8045) == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[(((_next_solutions__1_s0_i + _t8049) * 2) + _t8045)]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _t8028 = _730;
     int32_t _t8039 = (_next_solutions__1_s0_i + _t8049);
     double _731 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert (((_t8039 * 2) + _t8045) + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[(((_t8039 * 2) + _t8045) + 1)]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _732 = 
     /*@ with
      unfold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
      _distance[0]
     /*@ then
      fold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     ;
     double _733 = 
     /*@ with
      unfold [1\2]_float64_pred(_next_sol_);
      assert ((_t8039 * 2) + _t8046) == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_next_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _next_sol__stride_3, _n_antennas); @*/
      _next_sol_[((_t8039 * 2) + _t8046)]
     /*@ then
      fold [1\2]_float64_pred(_next_sol_); @*/
     ;
     /*@
      unfold next_solutions__1_pred(_next_solutions__1, 0, 0, 2, _next_solutions__1_s0_i, 0, 2, _next_solutions__1_s0_si, 0, _n_solutions, _next_solutions__1_s0_a, 0, _n_antennas);
      assert ((_t8039 * 2) + _t8048) == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*2*2) + ((_next_solutions__1_s0_a - 0)*2*2*_n_solutions) && perm(&_next_solutions__1[((_t8039 * 2) + _t8048)]) == (1\1); @*/
     _next_solutions__1[((_t8039 * 2) + _t8048)]= (_phase_only ? cos_f64((atan2_f64(_731, _t8028) + (_732 * _step_size))) : (((1.000000 - _step_size) * _t8028) + (_733 * _step_size)));
     /*@ fold next_solutions__1_pred(_next_solutions__1, 0, 0, 2, _next_solutions__1_s0_i, 0, 2, _next_solutions__1_s0_si, 0, _n_solutions, _next_solutions__1_s0_a, 0, _n_antennas); @*/
     /*@ ghost from_pred_distance(_distance, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, 1);
      @*/
    } // alloc _distance
    {
     double _distance[1];
     /*@ ghost to_pred_distance(_distance, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, 1);
      @*/
     // produce distance
     int32_t _t8040 = (_next_solutions__1_s0_i + _t8049);
     int32_t _t8041 = ((_t8040 * 2) + _t8045);
     int32_t _t8042 = ((_t8040 * 2) + _t8046);
     double _734 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert (_t8041 + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[(_t8041 + 1)]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _735 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert _t8041 == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[_t8041]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _736 = 
     /*@ with
      unfold [1\2]_float64_pred(_next_sol_);
      assert (_t8042 + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_next_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _next_sol__stride_3, _n_antennas); @*/
      _next_sol_[(_t8042 + 1)]
     /*@ then
      fold [1\2]_float64_pred(_next_sol_); @*/
     ;
     double _737 = 
     /*@ with
      unfold [1\2]_float64_pred(_next_sol_);
      assert _t8042 == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_next_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _next_sol__stride_3, _n_antennas); @*/
      _next_sol_[_t8042]
     /*@ then
      fold [1\2]_float64_pred(_next_sol_); @*/
     ;
     /*@
      unfold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     _distance[0]= (atan2_f64(_734, _735) - atan2_f64(_736, _737));
     /*@ fold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     double _738 = 
     /*@ with
      unfold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
      _distance[0]
     /*@ then
      fold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     ;
     double _t8032 = _738;
     /*@
      unfold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     _distance[0]= (((3.141593 < _t8032) ? -6.283185 : 6.283185) + _t8032);
     /*@ fold distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     // consume distance
     double _739 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert ((((_next_solutions__1_s0_i + _t8049) * 2) + _t8045) + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[((((_next_solutions__1_s0_i + _t8049) * 2) + _t8045) + 1)]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _t8035 = _739;
     int32_t _t8043 = (_next_solutions__1_s0_i + _t8049);
     double _740 = 
     /*@ with
      unfold [1\2]_float64_pred(_sol_);
      assert ((_t8043 * 2) + _t8045) == ((0 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_sol__stride_3);
      ghost lemma_4d_access(0, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _sol__stride_3, _n_antennas); @*/
      _sol_[((_t8043 * 2) + _t8045)]
     /*@ then
      fold [1\2]_float64_pred(_sol_); @*/
     ;
     double _741 = 
     /*@ with
      unfold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
      _distance[0]
     /*@ then
      fold [1\2]distance_pred(_distance, _next_solutions__1_s0_i, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, _next_solutions__1_s0_a, 1); @*/
     ;
     double _742 = 
     /*@ with
      unfold [1\2]_float64_pred(_next_sol_);
      assert (((_t8043 * 2) + _t8046) + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*4) + ((_next_solutions__1_s0_a - 0)*_next_sol__stride_3);
      ghost lemma_4d_access(1, 0, 1, 2, _next_solutions__1_s0_i, 0, 2, 2, _next_solutions__1_s0_si, 0, 4, _n_solutions, _next_solutions__1_s0_a, 0, _next_sol__stride_3, _n_antennas); @*/
      _next_sol_[(((_t8043 * 2) + _t8046) + 1)]
     /*@ then
      fold [1\2]_float64_pred(_next_sol_); @*/
     ;
     /*@
      unfold next_solutions__1_pred(_next_solutions__1, 1, 0, 2, _next_solutions__1_s0_i, 0, 2, _next_solutions__1_s0_si, 0, _n_solutions, _next_solutions__1_s0_a, 0, _n_antennas);
      assert (((_t8043 * 2) + _t8048) + 1) == ((1 - 0)*1) + ((_next_solutions__1_s0_i - 0)*2) + ((_next_solutions__1_s0_si - 0)*2*2) + ((_next_solutions__1_s0_a - 0)*2*2*_n_solutions) && perm(&_next_solutions__1[(((_t8043 * 2) + _t8048) + 1)]) == (1\1); @*/
     _next_solutions__1[(((_t8043 * 2) + _t8048) + 1)]= (_phase_only ? sin_f64((atan2_f64(_t8035, _740) + (_741 * _step_size))) : (((1.000000 - _step_size) * _t8035) + (_742 * _step_size)));
     /*@ fold next_solutions__1_pred(_next_solutions__1, 1, 0, 2, _next_solutions__1_s0_i, 0, 2, _next_solutions__1_s0_si, 0, _n_solutions, _next_solutions__1_s0_a, 0, _n_antennas); @*/
     /*@ ghost from_pred_distance(_distance, _next_solutions__1_s0_i, 1, _next_solutions__1_s0_si, 1, _next_solutions__1_s0_a, 1);
      @*/
    } // alloc _distance
   } // for _next_solutions__1_s0_i
  } // for _next_solutions__1_s0_si
 } // for _next_solutions__1_s0_a
 return 0;
}

#ifdef __cplusplus
}  // extern "C"
#endif

