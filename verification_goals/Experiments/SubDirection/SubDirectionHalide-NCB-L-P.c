
/* MACHINE GENERATED By Halide. */

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#ifndef HALIVER_GLOBALS
#define HALIVER_GLOBALS

struct halide_dimension_t {
    int32_t min, extent, stride;
    uint32_t flags;
};

inline void halide_unused(bool e){};

/*@
pure int max(int x, int y) = x > y ? x : y;

pure int min(int x, int y) = x > y ? y : x;

pure float max(float x, float y) = x > y ? x : y;

pure float min(float x, float y) = x > y ? y : x;

pure int abs(int x) = x >= 0 ? x : -x;

pure float abs(float x) = x >= 0 ? x : -x;

// Euclidean division is defined internally in VerCors
pure int hdiv(int x, int y) = y == 0 ? 0 : \euclidean_div(x, y);
pure int hmod(int x, int y) = y == 0 ? 0 : \euclidean_mod(x, y);
@*/

/*@
  requires y != 0;
  ensures \result == \euclidean_div(x, y);
@*/
inline int /*@ pure @*/ div_eucl(int x, int y)
{
    int q = x/y;
    int r = x%y;
    return r < 0 ? q + (y > 0 ? -1 : 1) : q;
}

/*@
  requires y != 0;
  ensures \result == \euclidean_mod(x, y);
@*/
inline int /*@ pure @*/ mod_eucl(int x, int y)
{
    int r = x%y;
    return (x >= 0 || r == 0) ? r : r + abs(y);
}

static inline int /*@ pure @*/ min(int x, int y) {return x < y ? x : y;}
static inline float /*@ pure @*/ fast_inverse_f32(float x) {return 1.0f/x;}

static inline float /*@ pure @*/ sqrt_f32(float x) {return sqrtf(x);}
static inline float /*@ pure @*/ sin_f32(float x) {return sinf(x);}
static inline float /*@ pure @*/ asin_f32(float x) {return asinf(x);}
static inline float /*@ pure @*/ cos_f32(float x) {return cosf(x);}
static inline float /*@ pure @*/ acos_f32(float x) {return acosf(x);}
static inline float /*@ pure @*/ tan_f32(float x) {return tanf(x);}
static inline float /*@ pure @*/ atan_f32(float x) {return atanf(x);}
static inline float /*@ pure @*/ atan2_f32(float x, float y) {return atan2f(x, y);}
static inline float /*@ pure @*/ sinh_f32(float x) {return sinhf(x);}
static inline float /*@ pure @*/ cosh_f32(float x) {return coshf(x);}
static inline float /*@ pure @*/ tanh_f32(float x) {return tanhf(x);}
static inline float /*@ pure @*/ hypot_f32(float x, float y) {return hypotf(x, y);}
static inline float /*@ pure @*/ exp_f32(float x) {return expf(x);}
static inline float /*@ pure @*/ log_f32(float x) {return logf(x);}
static inline float /*@ pure @*/ pow_f32(float x, float y) {return powf(x, y);}
static inline float /*@ pure @*/ floor_f32(float x) {return floorf(x);}
static inline float /*@ pure @*/ ceil_f32(float x) {return ceilf(x);}
static inline float /*@ pure @*/ round_f32(float x) {return roundf(x);}

static inline double /*@ pure @*/ sqrt_f64(double x) {return sqrt(x);}
static inline double /*@ pure @*/ sin_f64(double x) {return sin(x);}
static inline double /*@ pure @*/ asin_f64(double x) {return asin(x);}
static inline double /*@ pure @*/ cos_f64(double x) {return cos(x);}
static inline double /*@ pure @*/ acos_f64(double x) {return acos(x);}
static inline double /*@ pure @*/ tan_f64(double x) {return tan(x);}
static inline double /*@ pure @*/ atan_f64(double x) {return atan(x);}
static inline double /*@ pure @*/ atan2_f64(double x, double y) {return atan2(x, y);}
static inline double /*@ pure @*/ sinh_f64(double x) {return sinh(x);}
static inline double /*@ pure @*/ cosh_f64(double x) {return cosh(x);}
static inline double /*@ pure @*/ tanh_f64(double x) {return tanh(x);}
static inline double /*@ pure @*/ hypot_f64(double x, double y) {return hypot(x, y);}
static inline double /*@ pure @*/ exp_f64(double x) {return exp(x);}
static inline double /*@ pure @*/ log_f64(double x) {return log(x);}
static inline double /*@ pure @*/ pow_f64(double x, double y) {return pow(x, y);}
static inline double /*@ pure @*/ floor_f64(double x) {return floor(x);}
static inline double /*@ pure @*/ ceil_f64(double x) {return ceil(x);}
static inline double /*@ pure @*/ round_f64(double x) {return round(x);}

//inline float nan_f32() {return NAN;}
inline float nan_f32() {return 0.0f;}
/*@
inline resource dim_perm(struct halide_dimension_t *dim, rational p, int i) = 
 Perm(&dim[i], 1\2) **
 Perm(dim[i].min, 1\2) **
 Perm(dim[i].stride, 1\2) **
 Perm(dim[i].extent, 1\2) **
 dim[i].extent > 0
 ;
 
 requires a >= 0;
 requires b > 0;
 requires a < max_a;
 ensures a*b <= (max_a-1)*b;
 ensures \result;
 decreases b;
pure bool lemma_nonlinear(int a, int b, int max_a);// = b>1 ? lemma_nonlinear(a, b-1, max_a) : true;
 
 requires a-min_a >= 0 && a-min_a<extent_a;
 requires b-min_b >= 0 && b-min_b<extent_b;
 requires stride_a > 0;
 requires stride_b >= extent_a*stride_a;

 ensures 0 <= (b-min_b)*stride_b;
 ensures 0 <= (a-min_a)*stride_a + (b-min_b)*stride_b;
 ensures (a-min_a)*stride_a + (b-min_b)*stride_b < stride_b*extent_b;
 ensures \result;
 decreases;
pure bool lemma_2d_access(
 int a, int min_a, int stride_a, int extent_a,
 int b, int min_b, int stride_b, int extent_b);// = lemma_nonlinear(a-min_a, stride_a, extent_a) && lemma_nonlinear(b-min_b, stride_b, extent_b);

 requires a-min_a >= 0 && a-min_a < extent_a;
 requires b-min_b >= 0 && b-min_b < extent_b;
 requires c-min_c >= 0 && c-min_c < extent_c;
 requires stride_a > 0;
 requires stride_b >= extent_a * stride_a;
 requires stride_c >= extent_b * stride_b;
 
 ensures 0 <= (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c;
 ensures (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c < stride_c * extent_c;
 ensures \result;
 decreases;
pure bool lemma_3d_access(
  int a, int min_a, int stride_a, int extent_a,
  int b, int min_b, int stride_b, int extent_b,
  int c, int min_c, int stride_c, int extent_c
);// = lemma_2d_access(a, min_a, stride_a, extent_a, b, min_b, stride_b, extent_b) && lemma_nonlinear(c-min_c, stride_c, extent_c);


 requires a-min_a >= 0 && a-min_a < extent_a;
 requires b-min_b >= 0 && b-min_b < extent_b;
 requires c-min_c >= 0 && c-min_c < extent_c;
 requires d-min_d >= 0 && d-min_d < extent_d;
 requires stride_a > 0;
 requires stride_b >= extent_a * stride_a;
 requires stride_c >= extent_b * stride_b;
 requires stride_d >= extent_c * stride_c;

 ensures 0 <= (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d;
 ensures (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d < stride_d * extent_d;
 ensures \result;
 decreases;
pure bool lemma_4d_access(
  int a, int min_a, int stride_a, int extent_a,
  int b, int min_b, int stride_b, int extent_b,
  int c, int min_c, int stride_c, int extent_c,
  int d, int min_d, int stride_d, int extent_d
);// = lemma_3d_access(a, min_a, stride_a, extent_a, b, min_b, stride_b, extent_b, c, min_c, stride_c, extent_c) && lemma_nonlinear(d-min_d, stride_d, extent_d);

 requires a-min_a >= 0 && a-min_a < extent_a;
 requires b-min_b >= 0 && b-min_b < extent_b;
 requires c-min_c >= 0 && c-min_c < extent_c;
 requires d-min_d >= 0 && d-min_d < extent_d;
 requires e-min_e >= 0 && e-min_e < extent_e;
 requires stride_a > 0;
 requires stride_b >= extent_a * stride_a;
 requires stride_c >= extent_b * stride_b;
 requires stride_d >= extent_c * stride_c;
 requires stride_e >= extent_d * stride_d;

 ensures 0 <= (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d + (e-min_e) * stride_e;
 ensures (a-min_a) * stride_a + (b-min_b) * stride_b + (c-min_c) * stride_c + (d-min_d) * stride_d + (e-min_e) * stride_e < stride_e * extent_e;
 ensures \result;
 decreases;
pure bool lemma_5d_access(
  int a, int min_a, int stride_a, int extent_a,
  int b, int min_b, int stride_b, int extent_b,
  int c, int min_c, int stride_c, int extent_c,
  int d, int min_d, int stride_d, int extent_d,
  int e, int min_e, int stride_e, int extent_e
);// = lemma_4d_access(a, min_a, stride_a, extent_a, b, min_b, stride_b, extent_b, c, min_c, stride_c, extent_c, d, min_d, stride_d, extent_d) && lemma_nonlinear(e-min_e, stride_e, extent_e);

pure int split(int xi, int xo, int xmin, int factor) = xo*factor + xi +xmin;
@*/
#endif // HALIVER_GLOBALS

/*@
resource ant1_im_pred(
 int* data
 , int _0, int _0_min, int _0_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  data != NULL && \pointer_length(data) == _0_extent) ** 
  (\let int idx = (_0-_0_min)*1;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent;
 requires (\forall* int _0; _0 >= _0_min && _0 < _0_min + _0_extent; {:ant1_im_pred(_xs, _0, _0_min, _0_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent; Perm(&_xs[_i], 1\1));
void from_pred_ant1_im(int* _xs, int _0_min, int _0_extent);

 ghost
 context_everywhere _0_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0; _0 >= _0_min && _0 < _0_min + _0_extent; {:ant1_im_pred(_xs, _0, _0_min, _0_extent):});
void to_pred_ant1_im(int* _xs, int _0_min, int _0_extent);

resource _int32_pred(int* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );

resource ant2_im_pred(
 int* data
 , int _0, int _0_min, int _0_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  data != NULL && \pointer_length(data) == _0_extent) ** 
  (\let int idx = (_0-_0_min)*1;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent;
 requires (\forall* int _0; _0 >= _0_min && _0 < _0_min + _0_extent; {:ant2_im_pred(_xs, _0, _0_min, _0_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent; Perm(&_xs[_i], 1\1));
void from_pred_ant2_im(int* _xs, int _0_min, int _0_extent);

 ghost
 context_everywhere _0_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0; _0 >= _0_min && _0 < _0_min + _0_extent; {:ant2_im_pred(_xs, _0, _0_min, _0_extent):});
void to_pred_ant2_im(int* _xs, int _0_min, int _0_extent);

resource antenna_1_pred(
 int* data
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data != NULL && \pointer_length(data) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:antenna_1_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_antenna_1(int* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:antenna_1_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_antenna_1(int* _xs, int _v_min, int _v_extent);

resource antenna_2_pred(
 int* data
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data != NULL && \pointer_length(data) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:antenna_2_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_antenna_2(int* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:antenna_2_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_antenna_2(int* _xs, int _v_min, int _v_extent);

resource model_0_pred(
 float* data_0
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_0 != NULL && \pointer_length(data_0) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_0_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_0(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_0_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_0(float* _xs, int _v_min, int _v_extent);

resource model_1_pred(
 float* data_1
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_1 != NULL && \pointer_length(data_1) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_1_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_1(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_1_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_1(float* _xs, int _v_min, int _v_extent);

resource model_2_pred(
 float* data_2
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_2 != NULL && \pointer_length(data_2) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_2[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_2_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_2(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_2_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_2(float* _xs, int _v_min, int _v_extent);

resource model_3_pred(
 float* data_3
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_3 != NULL && \pointer_length(data_3) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_3[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_3_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_3(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_3_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_3(float* _xs, int _v_min, int _v_extent);

resource model_4_pred(
 float* data_4
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_4 != NULL && \pointer_length(data_4) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_4[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_4_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_4(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_4_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_4(float* _xs, int _v_min, int _v_extent);

resource model_5_pred(
 float* data_5
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_5 != NULL && \pointer_length(data_5) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_5[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_5_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_5(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_5_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_5(float* _xs, int _v_min, int _v_extent);

resource model_6_pred(
 float* data_6
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_6 != NULL && \pointer_length(data_6) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_6[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_6_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_6(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_6_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_6(float* _xs, int _v_min, int _v_extent);

resource model_7_pred(
 float* data_7
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_7 != NULL && \pointer_length(data_7) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_7[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_7_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_model_7(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:model_7_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_model_7(float* _xs, int _v_min, int _v_extent);

resource _float32_pred(float* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );

resource model__im_pred(
 float* data
 , int _0, int _0_min, int _0_extent, int _1, int _1_min, int _1_extent, int _2, int _2_min, int _2_extent, int _3, int _3_min, int _3_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  _1 >= _1_min && _1 < _1_min + _1_extent && 
  _2 >= _2_min && _2 < _2_min + _2_extent && 
  _3 >= _3_min && _3 < _3_min + _3_extent && 
  data != NULL && \pointer_length(data) == _0_extent * _1_extent * _2_extent * _3_extent && lemma_4d_access(_0, _0_min, 1, _0_extent, _1, _1_min, _0_extent, _1_extent, _2, _2_min, _0_extent * _1_extent, _2_extent, _3, _3_min, _0_extent * _1_extent * _2_extent, _3_extent)) ** 
  (\let int idx = (_0-_0_min)*1 + (_1-_1_min)*_0_extent + (_2-_2_min)*_0_extent * _1_extent + (_3-_3_min)*_0_extent * _1_extent * _2_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:model__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
void from_pred_model__im(float* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:model__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
void to_pred_model__im(float* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

resource sol_0_pred(
 float* data_0
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_0 != NULL && \pointer_length(data_0) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:sol_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_sol_0(float* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:sol_0_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_sol_0(float* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource sol_1_pred(
 float* data_1
 , int i, int i_min, int i_extent, int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( i >= i_min && i < i_min + i_extent && 
  si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_1 != NULL && \pointer_length(data_1) == i_extent * si_extent * a_extent && lemma_3d_access(i, i_min, 1, i_extent, si, si_min, i_extent, si_extent, a, a_min, i_extent * si_extent, a_extent)) ** 
  (\let int idx = (i-i_min)*1 + (si-si_min)*i_extent + (a-a_min)*i_extent * si_extent;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:sol_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_sol_1(float* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _i_extent > 0 && _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _i_extent*_si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _i_extent*_si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _i, int _si, int _a; _i >= _i_min && _i < _i_min + _i_extent && _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:sol_1_pred(_xs, _i, _i_min, _i_extent, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_sol_1(float* _xs, int _i_min, int _i_extent, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource sol__im_pred(
 double* data
 , int _0, int _0_min, int _0_extent, int _1, int _1_min, int _1_extent, int _2, int _2_min, int _2_extent, int _3, int _3_min, int _3_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  _1 >= _1_min && _1 < _1_min + _1_extent && 
  _2 >= _2_min && _2 < _2_min + _2_extent && 
  _3 >= _3_min && _3 < _3_min + _3_extent && 
  data != NULL && \pointer_length(data) == _0_extent * _1_extent * _2_extent * _3_extent && lemma_4d_access(_0, _0_min, 1, _0_extent, _1, _1_min, _0_extent, _1_extent, _2, _2_min, _0_extent * _1_extent, _2_extent, _3, _3_min, _0_extent * _1_extent * _2_extent, _3_extent)) ** 
  (\let int idx = (_0-_0_min)*1 + (_1-_1_min)*_0_extent + (_2-_2_min)*_0_extent * _1_extent + (_3-_3_min)*_0_extent * _1_extent * _2_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:sol__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
void from_pred_sol__im(double* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:sol__im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
void to_pred_sol__im(double* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

resource _float64_pred(double* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );

resource solution_index_pred(
 int* data
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data != NULL && \pointer_length(data) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:solution_index_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_solution_index(int* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:solution_index_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_solution_index(int* _xs, int _v_min, int _v_extent);

resource solution_map_im_pred(
 int* data
 , int _0, int _0_min, int _0_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  data != NULL && \pointer_length(data) == _0_extent) ** 
  (\let int idx = (_0-_0_min)*1;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent;
 requires (\forall* int _0; _0 >= _0_min && _0 < _0_min + _0_extent; {:solution_map_im_pred(_xs, _0, _0_min, _0_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent; Perm(&_xs[_i], 1\1));
void from_pred_solution_map_im(int* _xs, int _0_min, int _0_extent);

 ghost
 context_everywhere _0_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0; _0 >= _0_min && _0 < _0_min + _0_extent; {:solution_map_im_pred(_xs, _0, _0_min, _0_extent):});
void to_pred_solution_map_im(int* _xs, int _0_min, int _0_extent);

resource solutions_0_pred(
 float* data_0
 , int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_0 != NULL && \pointer_length(data_0) == si_extent * a_extent && lemma_2d_access(si, si_min, 1, si_extent, a, a_min, si_extent, a_extent)) ** 
  (\let int idx = (si-si_min)*1 + (a-a_min)*si_extent;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_0_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_solutions_0(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_0_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_solutions_0(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource solutions_1_pred(
 float* data_1
 , int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_1 != NULL && \pointer_length(data_1) == si_extent * a_extent && lemma_2d_access(si, si_min, 1, si_extent, a, a_min, si_extent, a_extent)) ** 
  (\let int idx = (si-si_min)*1 + (a-a_min)*si_extent;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_1_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_solutions_1(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_1_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_solutions_1(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource solutions_2_pred(
 float* data_2
 , int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_2 != NULL && \pointer_length(data_2) == si_extent * a_extent && lemma_2d_access(si, si_min, 1, si_extent, a, a_min, si_extent, a_extent)) ** 
  (\let int idx = (si-si_min)*1 + (a-a_min)*si_extent;
   Perm(&data_2[idx], write));

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_2_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_solutions_2(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_2_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_solutions_2(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource solutions_3_pred(
 float* data_3
 , int si, int si_min, int si_extent, int a, int a_min, int a_extent) = 
 ( si >= si_min && si < si_min + si_extent && 
  a >= a_min && a < a_min + a_extent && 
  data_3 != NULL && \pointer_length(data_3) == si_extent * a_extent && lemma_2d_access(si, si_min, 1, si_extent, a, a_min, si_extent, a_extent)) ** 
  (\let int idx = (si-si_min)*1 + (a-a_min)*si_extent;
   Perm(&data_3[idx], write));

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_3_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
void from_pred_solutions_3(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

 ghost
 context_everywhere _si_extent > 0 && _a_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _si_extent*_a_extent;
 requires (\forall* int _i; 0 <= _i && _i < _si_extent*_a_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _si, int _a; _si >= _si_min && _si < _si_min + _si_extent && _a >= _a_min && _a < _a_min + _a_extent; {:solutions_3_pred(_xs, _si, _si_min, _si_extent, _a, _a_min, _a_extent):});
void to_pred_solutions_3(float* _xs, int _si_min, int _si_extent, int _a_min, int _a_extent);

resource v_res0_0_pred(
 float* data_0
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_0 != NULL && \pointer_length(data_0) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_0_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_0(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_0_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_0(float* _xs, int _v_min, int _v_extent);

resource v_res0_1_pred(
 float* data_1
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_1 != NULL && \pointer_length(data_1) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_1_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_1(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_1_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_1(float* _xs, int _v_min, int _v_extent);

resource v_res0_2_pred(
 float* data_2
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_2 != NULL && \pointer_length(data_2) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_2[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_2_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_2(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_2_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_2(float* _xs, int _v_min, int _v_extent);

resource v_res0_3_pred(
 float* data_3
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_3 != NULL && \pointer_length(data_3) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_3[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_3_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_3(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_3_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_3(float* _xs, int _v_min, int _v_extent);

resource v_res0_4_pred(
 float* data_4
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_4 != NULL && \pointer_length(data_4) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_4[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_4_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_4(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_4_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_4(float* _xs, int _v_min, int _v_extent);

resource v_res0_5_pred(
 float* data_5
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_5 != NULL && \pointer_length(data_5) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_5[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_5_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_5(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_5_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_5(float* _xs, int _v_min, int _v_extent);

resource v_res0_6_pred(
 float* data_6
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_6 != NULL && \pointer_length(data_6) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_6[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_6_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_6(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_6_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_6(float* _xs, int _v_min, int _v_extent);

resource v_res0_7_pred(
 float* data_7
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_7 != NULL && \pointer_length(data_7) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_7[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_7_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res0_7(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:v_res0_7_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_v_res0_7(float* _xs, int _v_min, int _v_extent);

resource v_res_in_im_pred(
 float* data
 , int _0, int _0_min, int _0_extent, int _1, int _1_min, int _1_extent, int _2, int _2_min, int _2_extent, int _3, int _3_min, int _3_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  _1 >= _1_min && _1 < _1_min + _1_extent && 
  _2 >= _2_min && _2 < _2_min + _2_extent && 
  _3 >= _3_min && _3 < _3_min + _3_extent && 
  data != NULL && \pointer_length(data) == _0_extent * _1_extent * _2_extent * _3_extent && lemma_4d_access(_0, _0_min, 1, _0_extent, _1, _1_min, _0_extent, _1_extent, _2, _2_min, _0_extent * _1_extent, _2_extent, _3, _3_min, _0_extent * _1_extent * _2_extent, _3_extent)) ** 
  (\let int idx = (_0-_0_min)*1 + (_1-_1_min)*_0_extent + (_2-_2_min)*_0_extent * _1_extent + (_3-_3_min)*_0_extent * _1_extent * _2_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:v_res_in_im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res_in_im(float* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

 ghost
 context_everywhere _0_extent > 0 && _1_extent > 0 && _2_extent > 0 && _3_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _0_extent*_1_extent*_2_extent*_3_extent;
 requires (\forall* int _i; 0 <= _i && _i < _0_extent*_1_extent*_2_extent*_3_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _0, int _1, int _2, int _3; _0 >= _0_min && _0 < _0_min + _0_extent && _1 >= _1_min && _1 < _1_min + _1_extent && _2 >= _2_min && _2 < _2_min + _2_extent && _3 >= _3_min && _3 < _3_min + _3_extent; {:v_res_in_im_pred(_xs, _0, _0_min, _0_extent, _1, _1_min, _1_extent, _2, _2_min, _2_extent, _3, _3_min, _3_extent):});
void to_pred_v_res_in_im(float* _xs, int _0_min, int _0_extent, int _1_min, int _1_extent, int _2_min, int _2_extent, int _3_min, int _3_extent);

resource v_res_out_pred(
 float* data
 , int c, int c_min, int c_extent, int i, int i_min, int i_extent, int j, int j_min, int j_extent, int v, int v_min, int v_extent) = 
 ( c >= c_min && c < c_min + c_extent && 
  i >= i_min && i < i_min + i_extent && 
  j >= j_min && j < j_min + j_extent && 
  v >= v_min && v < v_min + v_extent && 
  data != NULL && \pointer_length(data) == c_extent * i_extent * j_extent * v_extent && lemma_4d_access(c, c_min, 1, c_extent, i, i_min, c_extent, i_extent, j, j_min, c_extent * i_extent, j_extent, v, v_min, c_extent * i_extent * j_extent, v_extent)) ** 
  (\let int idx = (c-c_min)*1 + (i-i_min)*c_extent + (j-j_min)*c_extent * i_extent + (v-v_min)*c_extent * i_extent * j_extent;
   Perm(&data[idx], write));

 ghost
 context_everywhere _c_extent > 0 && _i_extent > 0 && _j_extent > 0 && _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _c_extent*_i_extent*_j_extent*_v_extent;
 requires (\forall* int _c, int _i, int _j, int _v; _c >= _c_min && _c < _c_min + _c_extent && _i >= _i_min && _i < _i_min + _i_extent && _j >= _j_min && _j < _j_min + _j_extent && _v >= _v_min && _v < _v_min + _v_extent; {:v_res_out_pred(_xs, _c, _c_min, _c_extent, _i, _i_min, _i_extent, _j, _j_min, _j_extent, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _c_extent*_i_extent*_j_extent*_v_extent; Perm(&_xs[_i], 1\1));
void from_pred_v_res_out(float* _xs, int _c_min, int _c_extent, int _i_min, int _i_extent, int _j_min, int _j_extent, int _v_min, int _v_extent);

 ghost
 context_everywhere _c_extent > 0 && _i_extent > 0 && _j_extent > 0 && _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _c_extent*_i_extent*_j_extent*_v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _c_extent*_i_extent*_j_extent*_v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _c, int _i, int _j, int _v; _c >= _c_min && _c < _c_min + _c_extent && _i >= _i_min && _i < _i_min + _i_extent && _j >= _j_min && _j < _j_min + _j_extent && _v >= _v_min && _v < _v_min + _v_extent; {:v_res_out_pred(_xs, _c, _c_min, _c_extent, _i, _i_min, _i_extent, _j, _j_min, _j_extent, _v, _v_min, _v_extent):});
void to_pred_v_res_out(float* _xs, int _c_min, int _c_extent, int _i_min, int _i_extent, int _j_min, int _j_extent, int _v_min, int _v_extent);

resource vis_out_0_pred(
 float* data_0
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_0 != NULL && \pointer_length(data_0) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_0[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_0_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_0(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_0_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_0(float* _xs, int _v_min, int _v_extent);

resource vis_out_1_pred(
 float* data_1
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_1 != NULL && \pointer_length(data_1) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_1[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_1_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_1(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_1_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_1(float* _xs, int _v_min, int _v_extent);

resource vis_out_2_pred(
 float* data_2
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_2 != NULL && \pointer_length(data_2) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_2[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_2_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_2(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_2_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_2(float* _xs, int _v_min, int _v_extent);

resource vis_out_3_pred(
 float* data_3
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_3 != NULL && \pointer_length(data_3) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_3[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_3_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_3(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_3_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_3(float* _xs, int _v_min, int _v_extent);

resource vis_out_4_pred(
 float* data_4
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_4 != NULL && \pointer_length(data_4) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_4[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_4_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_4(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_4_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_4(float* _xs, int _v_min, int _v_extent);

resource vis_out_5_pred(
 float* data_5
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_5 != NULL && \pointer_length(data_5) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_5[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_5_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_5(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_5_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_5(float* _xs, int _v_min, int _v_extent);

resource vis_out_6_pred(
 float* data_6
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_6 != NULL && \pointer_length(data_6) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_6[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_6_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_6(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_6_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_6(float* _xs, int _v_min, int _v_extent);

resource vis_out_7_pred(
 float* data_7
 , int v, int v_min, int v_extent) = 
 ( v >= v_min && v < v_min + v_extent && 
  data_7 != NULL && \pointer_length(data_7) == v_extent) ** 
  (\let int idx = (v-v_min)*1;
   Perm(&data_7[idx], write));

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_7_pred(_xs, _v, _v_min, _v_extent):});
 ensures (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
void from_pred_vis_out_7(float* _xs, int _v_min, int _v_extent);

 ghost
 context_everywhere _v_extent > 0;
 context_everywhere _xs != NULL && \pointer_length(_xs) == _v_extent;
 requires (\forall* int _i; 0 <= _i && _i < _v_extent; Perm(&_xs[_i], 1\1));
 ensures (\forall* int _v; _v >= _v_min && _v < _v_min + _v_extent; {:vis_out_7_pred(_xs, _v, _v_min, _v_extent):});
void to_pred_vis_out_7(float* _xs, int _v_min, int _v_extent);


@*/
#ifndef HALIDE_BUFFER_TYPE_DOUBLE
#define HALIDE_BUFFER_TYPE_DOUBLE
struct halide_buffer_double {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    double *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline double *_halide_buffer_get_host_double(struct halide_buffer_double *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_double(struct halide_buffer_double *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_DOUBLE
#ifndef HALIDE_BUFFER_TYPE_INT32_T
#define HALIDE_BUFFER_TYPE_INT32_T
struct halide_buffer_int32_t {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    int32_t *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline int32_t *_halide_buffer_get_host_int32_t(struct halide_buffer_int32_t *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_int32_t(struct halide_buffer_int32_t *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_INT32_T
#ifndef HALIDE_BUFFER_TYPE_FLOAT
#define HALIDE_BUFFER_TYPE_FLOAT
struct halide_buffer_float {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    float *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline float *_halide_buffer_get_host_float(struct halide_buffer_float *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_float(struct halide_buffer_float *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_FLOAT
//@ pure float pure_sol_(int x);
//@ pure int pure_solution_map(int x);
//@ pure int pure_ant1(int x);
//@ pure int pure_ant2(int x);
//@ pure float pure_model_(int x);
//@ pure float pure_v_res_in(int x);
//@ pure float pure_v_res_out(int x);



#ifdef __cplusplus
extern "C" {
#endif

/*@
 context buffer_double(_sol__buffer, 1\2, 4);
 context dim_perm(_sol__buffer->dim, 1\2, 0);
 context dim_perm(_sol__buffer->dim, 1\2, 1);
 context dim_perm(_sol__buffer->dim, 1\2, 2);
 context dim_perm(_sol__buffer->dim, 1\2, 3);
 context \pointer_length(_sol__buffer->host) == _n_antennas * _n_solutions*4;
 context buffer_int32_t(_solution_map_buffer, 1\2, 1);
 context dim_perm(_solution_map_buffer->dim, 1\2, 0);
 context \pointer_length(_solution_map_buffer->host) == _n_vis;
 context buffer_int32_t(_ant1_buffer, 1\2, 1);
 context dim_perm(_ant1_buffer->dim, 1\2, 0);
 context \pointer_length(_ant1_buffer->host) == _n_vis;
 context buffer_int32_t(_ant2_buffer, 1\2, 1);
 context dim_perm(_ant2_buffer->dim, 1\2, 0);
 context \pointer_length(_ant2_buffer->host) == _n_vis;
 context buffer_float(_model__buffer, 1\2, 4);
 context dim_perm(_model__buffer->dim, 1\2, 0);
 context dim_perm(_model__buffer->dim, 1\2, 1);
 context dim_perm(_model__buffer->dim, 1\2, 2);
 context dim_perm(_model__buffer->dim, 1\2, 3);
 context \pointer_length(_model__buffer->host) == 8*_n_vis;
 context buffer_float(_v_res_in_buffer, 1\2, 4);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 0);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 1);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 2);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 3);
 context \pointer_length(_v_res_in_buffer->host) == 8*_n_vis;
 context buffer_float(_v_res_out_buffer, 1\2, 4);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 0);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 1);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 2);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 3);
 context \pointer_length(_v_res_out_buffer->host) == 8*_n_vis;
 context _ant1_buffer->host != _solution_map_buffer->host;
 context _ant2_buffer->host != _solution_map_buffer->host;
 context _ant2_buffer->host != _ant1_buffer->host;
 context _model__buffer->host != _sol__buffer->host;
 context _v_res_in_buffer->host != _sol__buffer->host;
 context _v_res_in_buffer->host != _model__buffer->host;
 context _v_res_out_buffer->host != _sol__buffer->host;
 context _v_res_out_buffer->host != _model__buffer->host;
 context _v_res_out_buffer->host != _v_res_in_buffer->host;
 context _ant1_buffer->dim[0].min == 0 && _ant1_buffer->dim[0].extent == _n_vis && _ant1_buffer->dim[0].stride == 1;
 context [1\2]_int32_pred(_ant1_buffer->host);
 requires (\forall int _0; 0 <= _0 && _0 < _n_vis; (\unfolding [1\2]_int32_pred(_ant1_buffer->host) \in 0 <= _ant1_buffer->host[_0] && _ant1_buffer->host[_0] < _n_antennas));
 context _ant2_buffer->dim[0].min == 0 && _ant2_buffer->dim[0].extent == _n_vis && _ant2_buffer->dim[0].stride == 1;
 context [1\2]_int32_pred(_ant2_buffer->host);
 requires (\forall int _0; 0 <= _0 && _0 < _n_vis; (\unfolding [1\2]_int32_pred(_ant2_buffer->host) \in 0 <= _ant2_buffer->host[_0] && _ant2_buffer->host[_0] < _n_antennas));
 context _model__buffer->dim[0].min == 0 && _model__buffer->dim[0].extent == 2 && _model__buffer->dim[0].stride == 1;
 context _model__buffer->dim[1].min == 0 && _model__buffer->dim[1].extent == 2 && _model__buffer->dim[1].stride == 2;
 context _model__buffer->dim[2].min == 0 && _model__buffer->dim[2].extent == 2 && _model__buffer->dim[2].stride == 4;
 context _model__buffer->dim[3].min == 0 && _model__buffer->dim[3].extent == _n_vis && _model__buffer->dim[3].stride == 8;
 context [1\2]_float32_pred(_model__buffer->host);
 context _sol__buffer->dim[0].min == 0 && _sol__buffer->dim[0].extent == 2 && _sol__buffer->dim[0].stride == 1;
 context _sol__buffer->dim[1].min == 0 && _sol__buffer->dim[1].extent == 2 && _sol__buffer->dim[1].stride == 2;
 context _sol__buffer->dim[2].min == 0 && _sol__buffer->dim[2].extent == _n_solutions && _sol__buffer->dim[2].stride == 4;
 context _sol__buffer->dim[3].min == 0 && _sol__buffer->dim[3].extent == _n_antennas && _sol__buffer->dim[3].stride == _n_solutions*4;
 context [1\2]_float64_pred(_sol__buffer->host);
 context _solution_map_buffer->dim[0].min == 0 && _solution_map_buffer->dim[0].extent == _n_vis && _solution_map_buffer->dim[0].stride == 1;
 context [1\2]_int32_pred(_solution_map_buffer->host);
 requires (\forall int _0; 0 <= _0 && _0 < _n_vis; (\unfolding [1\2]_int32_pred(_solution_map_buffer->host) \in _solution_index0 <= _solution_map_buffer->host[_0] && _solution_map_buffer->host[_0] < _n_dir_sol + _solution_index0));
 context _v_res_in_buffer->dim[0].min == 0 && _v_res_in_buffer->dim[0].extent == 2 && _v_res_in_buffer->dim[0].stride == 1;
 context _v_res_in_buffer->dim[1].min == 0 && _v_res_in_buffer->dim[1].extent == 2 && _v_res_in_buffer->dim[1].stride == 2;
 context _v_res_in_buffer->dim[2].min == 0 && _v_res_in_buffer->dim[2].extent == 2 && _v_res_in_buffer->dim[2].stride == 4;
 context _v_res_in_buffer->dim[3].min == 0 && _v_res_in_buffer->dim[3].extent == _n_vis && _v_res_in_buffer->dim[3].stride == 8;
 context [1\2]_float32_pred(_v_res_in_buffer->host);
 context _v_res_out_buffer->dim[0].min == 0 && _v_res_out_buffer->dim[0].extent == 2 && _v_res_out_buffer->dim[0].stride == 1;
 context _v_res_out_buffer->dim[1].min == 0 && _v_res_out_buffer->dim[1].extent == 2 && _v_res_out_buffer->dim[1].stride == 2;
 context _v_res_out_buffer->dim[2].min == 0 && _v_res_out_buffer->dim[2].extent == 2 && _v_res_out_buffer->dim[2].stride == 4;
 context _v_res_out_buffer->dim[3].min == 0 && _v_res_out_buffer->dim[3].extent == _n_vis && _v_res_out_buffer->dim[3].stride == 8;
 context (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; {:v_res_out_pred(_v_res_out_buffer->host, _0, 0, 2, _1, 0, 2, _2, 0, 2, _3, 0, _n_vis):});
 context 0 <= _solution_index0 && 0 < _n_dir_sol && _n_dir_sol + _solution_index0 <= _n_solutions && 0 < _n_antennas && 0 < _n_vis && 0 < _n_solutions && _n_antennas == 50 && _n_solutions == 8 && _n_vis == 230930;
@*/
int SubDirection(struct halide_buffer_double *_sol__buffer, struct halide_buffer_int32_t *_solution_map_buffer, struct halide_buffer_int32_t *_ant1_buffer, struct halide_buffer_int32_t *_ant2_buffer, struct halide_buffer_float *_model__buffer, struct halide_buffer_float *_v_res_in_buffer, int32_t _solution_index0, int32_t _n_dir_sol, int32_t _n_vis, int32_t _n_solutions, int32_t _n_antennas, struct halide_buffer_float *_v_res_out_buffer) {
 int32_t* _ant1 = _halide_buffer_get_host_int32_t(_ant1_buffer);
 int32_t _ant1_min_0 = _halide_buffer_get_min_int32_t(_ant1_buffer, 0);
 int32_t _ant1_extent_0 = _halide_buffer_get_extent_int32_t(_ant1_buffer, 0);
 int32_t _ant1_stride_0 = _halide_buffer_get_stride_int32_t(_ant1_buffer, 0);
 int32_t* _ant2 = _halide_buffer_get_host_int32_t(_ant2_buffer);
 int32_t _ant2_min_0 = _halide_buffer_get_min_int32_t(_ant2_buffer, 0);
 int32_t _ant2_extent_0 = _halide_buffer_get_extent_int32_t(_ant2_buffer, 0);
 int32_t _ant2_stride_0 = _halide_buffer_get_stride_int32_t(_ant2_buffer, 0);
 float* _model_ = _halide_buffer_get_host_float(_model__buffer);
 int32_t _model__min_0 = _halide_buffer_get_min_float(_model__buffer, 0);
 int32_t _model__extent_0 = _halide_buffer_get_extent_float(_model__buffer, 0);
 int32_t _model__stride_0 = _halide_buffer_get_stride_float(_model__buffer, 0);
 int32_t _model__min_1 = _halide_buffer_get_min_float(_model__buffer, 1);
 int32_t _model__extent_1 = _halide_buffer_get_extent_float(_model__buffer, 1);
 int32_t _model__stride_1 = _halide_buffer_get_stride_float(_model__buffer, 1);
 int32_t _model__min_2 = _halide_buffer_get_min_float(_model__buffer, 2);
 int32_t _model__extent_2 = _halide_buffer_get_extent_float(_model__buffer, 2);
 int32_t _model__stride_2 = _halide_buffer_get_stride_float(_model__buffer, 2);
 int32_t _model__min_3 = _halide_buffer_get_min_float(_model__buffer, 3);
 int32_t _model__extent_3 = _halide_buffer_get_extent_float(_model__buffer, 3);
 int32_t _model__stride_3 = _halide_buffer_get_stride_float(_model__buffer, 3);
 double* _sol_ = _halide_buffer_get_host_double(_sol__buffer);
 int32_t _sol__min_0 = _halide_buffer_get_min_double(_sol__buffer, 0);
 int32_t _sol__extent_0 = _halide_buffer_get_extent_double(_sol__buffer, 0);
 int32_t _sol__stride_0 = _halide_buffer_get_stride_double(_sol__buffer, 0);
 int32_t _sol__min_1 = _halide_buffer_get_min_double(_sol__buffer, 1);
 int32_t _sol__extent_1 = _halide_buffer_get_extent_double(_sol__buffer, 1);
 int32_t _sol__stride_1 = _halide_buffer_get_stride_double(_sol__buffer, 1);
 int32_t _sol__min_2 = _halide_buffer_get_min_double(_sol__buffer, 2);
 int32_t _sol__extent_2 = _halide_buffer_get_extent_double(_sol__buffer, 2);
 int32_t _sol__stride_2 = _halide_buffer_get_stride_double(_sol__buffer, 2);
 int32_t _sol__min_3 = _halide_buffer_get_min_double(_sol__buffer, 3);
 int32_t _sol__extent_3 = _halide_buffer_get_extent_double(_sol__buffer, 3);
 int32_t _sol__stride_3 = _halide_buffer_get_stride_double(_sol__buffer, 3);
 int32_t* _solution_map = _halide_buffer_get_host_int32_t(_solution_map_buffer);
 int32_t _solution_map_min_0 = _halide_buffer_get_min_int32_t(_solution_map_buffer, 0);
 int32_t _solution_map_extent_0 = _halide_buffer_get_extent_int32_t(_solution_map_buffer, 0);
 int32_t _solution_map_stride_0 = _halide_buffer_get_stride_int32_t(_solution_map_buffer, 0);
 float* _v_res_in = _halide_buffer_get_host_float(_v_res_in_buffer);
 int32_t _v_res_in_min_0 = _halide_buffer_get_min_float(_v_res_in_buffer, 0);
 int32_t _v_res_in_extent_0 = _halide_buffer_get_extent_float(_v_res_in_buffer, 0);
 int32_t _v_res_in_stride_0 = _halide_buffer_get_stride_float(_v_res_in_buffer, 0);
 int32_t _v_res_in_min_1 = _halide_buffer_get_min_float(_v_res_in_buffer, 1);
 int32_t _v_res_in_extent_1 = _halide_buffer_get_extent_float(_v_res_in_buffer, 1);
 int32_t _v_res_in_stride_1 = _halide_buffer_get_stride_float(_v_res_in_buffer, 1);
 int32_t _v_res_in_min_2 = _halide_buffer_get_min_float(_v_res_in_buffer, 2);
 int32_t _v_res_in_extent_2 = _halide_buffer_get_extent_float(_v_res_in_buffer, 2);
 int32_t _v_res_in_stride_2 = _halide_buffer_get_stride_float(_v_res_in_buffer, 2);
 int32_t _v_res_in_min_3 = _halide_buffer_get_min_float(_v_res_in_buffer, 3);
 int32_t _v_res_in_extent_3 = _halide_buffer_get_extent_float(_v_res_in_buffer, 3);
 int32_t _v_res_in_stride_3 = _halide_buffer_get_stride_float(_v_res_in_buffer, 3);
 float* _v_res_out = _halide_buffer_get_host_float(_v_res_out_buffer);
 int32_t _v_res_out_min_0 = _halide_buffer_get_min_float(_v_res_out_buffer, 0);
 int32_t _v_res_out_extent_0 = _halide_buffer_get_extent_float(_v_res_out_buffer, 0);
 int32_t _v_res_out_stride_0 = _halide_buffer_get_stride_float(_v_res_out_buffer, 0);
 int32_t _v_res_out_min_1 = _halide_buffer_get_min_float(_v_res_out_buffer, 1);
 int32_t _v_res_out_extent_1 = _halide_buffer_get_extent_float(_v_res_out_buffer, 1);
 int32_t _v_res_out_stride_1 = _halide_buffer_get_stride_float(_v_res_out_buffer, 1);
 int32_t _v_res_out_min_2 = _halide_buffer_get_min_float(_v_res_out_buffer, 2);
 int32_t _v_res_out_extent_2 = _halide_buffer_get_extent_float(_v_res_out_buffer, 2);
 int32_t _v_res_out_stride_2 = _halide_buffer_get_stride_float(_v_res_out_buffer, 2);
 int32_t _v_res_out_min_3 = _halide_buffer_get_min_float(_v_res_out_buffer, 3);
 int32_t _v_res_out_extent_3 = _halide_buffer_get_extent_float(_v_res_out_buffer, 3);
 int32_t _v_res_out_stride_3 = _halide_buffer_get_stride_float(_v_res_out_buffer, 3);
 halide_unused((_ant1_stride_0 == 1));
 halide_unused((_ant1_min_0 == 0));
 halide_unused((_ant1_extent_0 == _n_vis));
 halide_unused((_ant2_stride_0 == 1));
 halide_unused((_ant2_min_0 == 0));
 halide_unused((_ant2_extent_0 == _n_vis));
 halide_unused((_model__stride_0 == 1));
 halide_unused((_model__min_0 == 0));
 halide_unused((_model__extent_0 == 2));
 halide_unused((_model__stride_1 == 2));
 halide_unused((_model__min_1 == 0));
 halide_unused((_model__extent_1 == 2));
 halide_unused((_model__stride_2 == 4));
 halide_unused((_model__min_2 == 0));
 halide_unused((_model__extent_2 == 2));
 halide_unused((_model__stride_3 == 8));
 halide_unused((_model__min_3 == 0));
 halide_unused((_model__extent_3 == _n_vis));
 halide_unused((_sol__stride_0 == 1));
 halide_unused((_sol__min_0 == 0));
 halide_unused((_sol__extent_0 == 2));
 halide_unused((_sol__stride_1 == 2));
 halide_unused((_sol__min_1 == 0));
 halide_unused((_sol__extent_1 == 2));
 halide_unused((_sol__stride_2 == 4));
 halide_unused((_sol__min_2 == 0));
 halide_unused((_sol__extent_2 == _n_solutions));
 halide_unused((_sol__stride_3 == (_n_solutions * 4)));
 halide_unused((_sol__min_3 == 0));
 halide_unused((_sol__extent_3 == _n_antennas));
 halide_unused((_solution_map_stride_0 == 1));
 halide_unused((_solution_map_min_0 == 0));
 halide_unused((_solution_map_extent_0 == _n_vis));
 halide_unused((_v_res_in_stride_0 == 1));
 halide_unused((_v_res_in_min_0 == 0));
 halide_unused((_v_res_in_extent_0 == 2));
 halide_unused((_v_res_in_stride_1 == 2));
 halide_unused((_v_res_in_min_1 == 0));
 halide_unused((_v_res_in_extent_1 == 2));
 halide_unused((_v_res_in_stride_2 == 4));
 halide_unused((_v_res_in_min_2 == 0));
 halide_unused((_v_res_in_extent_2 == 2));
 halide_unused((_v_res_in_stride_3 == 8));
 halide_unused((_v_res_in_min_3 == 0));
 halide_unused((_v_res_in_extent_3 == _n_vis));
 halide_unused((_v_res_out_stride_0 == 1));
 halide_unused((_v_res_out_min_0 == 0));
 halide_unused((_v_res_out_extent_0 == 2));
 halide_unused((_v_res_out_stride_1 == 2));
 halide_unused((_v_res_out_min_1 == 0));
 halide_unused((_v_res_out_extent_1 == 2));
 halide_unused((_v_res_out_stride_2 == 4));
 halide_unused((_v_res_out_min_2 == 0));
 halide_unused((_v_res_out_extent_2 == 2));
 halide_unused((_v_res_out_stride_3 == 8));
 halide_unused((_v_res_out_min_3 == 0));
 halide_unused((_v_res_out_extent_3 == _n_vis));
 {
  int64_t _222 = _n_vis;
  int64_t _223 = _222;
  float *_v_res0_0 = (float  *)malloc(sizeof(float )*_223);
  /*@ ghost to_pred_v_res0_0(_v_res0_0, 0, _n_vis);
   @*/
  {
   int64_t _224 = _n_vis;
   int64_t _225 = _224;
   float *_v_res0_1 = (float  *)malloc(sizeof(float )*_225);
   /*@ ghost to_pred_v_res0_1(_v_res0_1, 0, _n_vis);
    @*/
   {
    int64_t _226 = _n_vis;
    int64_t _227 = _226;
    float *_v_res0_2 = (float  *)malloc(sizeof(float )*_227);
    /*@ ghost to_pred_v_res0_2(_v_res0_2, 0, _n_vis);
     @*/
    {
     int64_t _228 = _n_vis;
     int64_t _229 = _228;
     float *_v_res0_3 = (float  *)malloc(sizeof(float )*_229);
     /*@ ghost to_pred_v_res0_3(_v_res0_3, 0, _n_vis);
      @*/
     {
      int64_t _230 = _n_vis;
      int64_t _231 = _230;
      float *_v_res0_4 = (float  *)malloc(sizeof(float )*_231);
      /*@ ghost to_pred_v_res0_4(_v_res0_4, 0, _n_vis);
       @*/
      {
       int64_t _232 = _n_vis;
       int64_t _233 = _232;
       float *_v_res0_5 = (float  *)malloc(sizeof(float )*_233);
       /*@ ghost to_pred_v_res0_5(_v_res0_5, 0, _n_vis);
        @*/
       {
        int64_t _234 = _n_vis;
        int64_t _235 = _234;
        float *_v_res0_6 = (float  *)malloc(sizeof(float )*_235);
        /*@ ghost to_pred_v_res0_6(_v_res0_6, 0, _n_vis);
         @*/
        {
         int64_t _236 = _n_vis;
         int64_t _237 = _236;
         float *_v_res0_7 = (float  *)malloc(sizeof(float )*_237);
         /*@ ghost to_pred_v_res0_7(_v_res0_7, 0, _n_vis);
          @*/
         // produce v_res0
         /*@
          loop_invariant 0 <= _v_res0_s0_v && _v_res0_s0_v <= 0 + _n_vis;
          loop_invariant [1\2]_float32_pred(_v_res_in);
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_0_pred(_v_res0_0, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_1_pred(_v_res0_1, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_2_pred(_v_res0_2, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_3_pred(_v_res0_3, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_4_pred(_v_res0_4, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_5_pred(_v_res0_5, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_6_pred(_v_res0_6, _v_res0_s0_v_forall, 0, _n_vis):});
          loop_invariant (\forall* int _v_res0_s0_v_forall; 0 <= _v_res0_s0_v_forall && _v_res0_s0_v_forall < _n_vis; {:v_res0_7_pred(_v_res0_7, _v_res0_s0_v_forall, 0, _n_vis):});
         @*/
         for (int _v_res0_s0_v = 0; _v_res0_s0_v < 0 + _n_vis; _v_res0_s0_v++)
         {
          float _238 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[(_v_res0_s0_v * 8)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_0_pred(_v_res0_0, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_0[_v_res0_s0_v]= _238;
          /*@ fold v_res0_0_pred(_v_res0_0, _v_res0_s0_v, 0, _n_vis); @*/
          float _239 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 1)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_1_pred(_v_res0_1, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_1[_v_res0_s0_v]= _239;
          /*@ fold v_res0_1_pred(_v_res0_1, _v_res0_s0_v, 0, _n_vis); @*/
          float _240 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 2)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_2_pred(_v_res0_2, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_2[_v_res0_s0_v]= _240;
          /*@ fold v_res0_2_pred(_v_res0_2, _v_res0_s0_v, 0, _n_vis); @*/
          float _241 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 3)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_3_pred(_v_res0_3, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_3[_v_res0_s0_v]= _241;
          /*@ fold v_res0_3_pred(_v_res0_3, _v_res0_s0_v, 0, _n_vis); @*/
          float _242 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 4)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_4_pred(_v_res0_4, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_4[_v_res0_s0_v]= _242;
          /*@ fold v_res0_4_pred(_v_res0_4, _v_res0_s0_v, 0, _n_vis); @*/
          float _243 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 5)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_5_pred(_v_res0_5, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_5[_v_res0_s0_v]= _243;
          /*@ fold v_res0_5_pred(_v_res0_5, _v_res0_s0_v, 0, _n_vis); @*/
          float _244 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 6)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_6_pred(_v_res0_6, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_6[_v_res0_s0_v]= _244;
          /*@ fold v_res0_6_pred(_v_res0_6, _v_res0_s0_v, 0, _n_vis); @*/
          float _245 = 
          /*@ with
           unfold [1\2]_float32_pred(_v_res_in); @*/
           _v_res_in[((_v_res0_s0_v * 8) + 7)]
          /*@ then
           fold [1\2]_float32_pred(_v_res_in); @*/
          ;
          /*@
           unfold v_res0_7_pred(_v_res0_7, _v_res0_s0_v, 0, _n_vis); @*/
          _v_res0_7[_v_res0_s0_v]= _245;
          /*@ fold v_res0_7_pred(_v_res0_7, _v_res0_s0_v, 0, _n_vis); @*/
         } // for _v_res0_s0_v
         // produce v_res_out
         // consume v_res0
         /*@
          loop_invariant 0 <= _v_res_out_s0_v && _v_res_out_s0_v <= 0 + _n_vis;
          loop_invariant [1\2]_int32_pred(_ant1);
          loop_invariant (\unfolding [1\2]_int32_pred(_ant1) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant1[_0] && _ant1[_0] < _n_antennas));
          loop_invariant [1\2]_int32_pred(_ant2);
          loop_invariant (\unfolding [1\2]_int32_pred(_ant2) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant2[_0] && _ant2[_0] < _n_antennas));
          loop_invariant [1\2]_float32_pred(_model_);
          loop_invariant [1\2]_float64_pred(_sol_);
          loop_invariant [1\2]_int32_pred(_solution_map);
          loop_invariant (\unfolding [1\2]_int32_pred(_solution_map) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_index0 <= _solution_map[_0] && _solution_map[_0] < _n_dir_sol + _solution_index0));
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_0_pred(_v_res0_0, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_1_pred(_v_res0_1, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_2_pred(_v_res0_2, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_3_pred(_v_res0_3, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_4_pred(_v_res0_4, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_5_pred(_v_res0_5, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_6_pred(_v_res0_6, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_7_pred(_v_res0_7, _v, 0, _n_vis):});
          loop_invariant (\forall* int _v_res_out_s0_v_forall, int _v_res_out_s0_j_forall, int _v_res_out_s0_i_forall, int _v_res_out_s0_c_forall; 0 <= _v_res_out_s0_v_forall && _v_res_out_s0_v_forall < _n_vis && 0 <= _v_res_out_s0_j_forall && _v_res_out_s0_j_forall < 2 && 0 <= _v_res_out_s0_i_forall && _v_res_out_s0_i_forall < 2 && 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; {:v_res_out_pred(_v_res_out, _v_res_out_s0_c_forall, 0, 2, _v_res_out_s0_i_forall, 0, 2, _v_res_out_s0_j_forall, 0, 2, _v_res_out_s0_v_forall, 0, _n_vis):});
         @*/
         for (int _v_res_out_s0_v = 0; _v_res_out_s0_v < 0 + _n_vis; _v_res_out_s0_v++)
         {
          /*@
           loop_invariant 0 <= _v_res_out_s0_j && _v_res_out_s0_j <= 0 + 2;
           loop_invariant [1\2]_int32_pred(_ant1);
           loop_invariant (\unfolding [1\2]_int32_pred(_ant1) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant1[_0] && _ant1[_0] < _n_antennas));
           loop_invariant [1\2]_int32_pred(_ant2);
           loop_invariant (\unfolding [1\2]_int32_pred(_ant2) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant2[_0] && _ant2[_0] < _n_antennas));
           loop_invariant [1\2]_float32_pred(_model_);
           loop_invariant [1\2]_float64_pred(_sol_);
           loop_invariant [1\2]_int32_pred(_solution_map);
           loop_invariant (\unfolding [1\2]_int32_pred(_solution_map) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_index0 <= _solution_map[_0] && _solution_map[_0] < _n_dir_sol + _solution_index0));
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_0_pred(_v_res0_0, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_1_pred(_v_res0_1, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_2_pred(_v_res0_2, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_3_pred(_v_res0_3, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_4_pred(_v_res0_4, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_5_pred(_v_res0_5, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_6_pred(_v_res0_6, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_7_pred(_v_res0_7, _v, 0, _n_vis):});
           loop_invariant (\forall* int _v_res_out_s0_j_forall, int _v_res_out_s0_i_forall, int _v_res_out_s0_c_forall; 0 <= _v_res_out_s0_j_forall && _v_res_out_s0_j_forall < 2 && 0 <= _v_res_out_s0_i_forall && _v_res_out_s0_i_forall < 2 && 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; {:v_res_out_pred(_v_res_out, _v_res_out_s0_c_forall, 0, 2, _v_res_out_s0_i_forall, 0, 2, _v_res_out_s0_j_forall, 0, 2, _v_res_out_s0_v, 0, _n_vis):});
          @*/
          for (int _v_res_out_s0_j = 0; _v_res_out_s0_j < 0 + 2; _v_res_out_s0_j++)
          {
           bool _t3690 = (_v_res_out_s0_j == 1);
           bool _t3688 = (_v_res_out_s0_j == 0);
           int32_t _t3691 = (((_v_res_out_s0_v * 2) + _v_res_out_s0_j) * 4);
           /*@
            loop_invariant 0 <= _v_res_out_s0_i && _v_res_out_s0_i <= 0 + 2;
            loop_invariant [1\2]_int32_pred(_ant1);
            loop_invariant (\unfolding [1\2]_int32_pred(_ant1) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant1[_0] && _ant1[_0] < _n_antennas));
            loop_invariant [1\2]_int32_pred(_ant2);
            loop_invariant (\unfolding [1\2]_int32_pred(_ant2) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant2[_0] && _ant2[_0] < _n_antennas));
            loop_invariant [1\2]_float32_pred(_model_);
            loop_invariant [1\2]_float64_pred(_sol_);
            loop_invariant [1\2]_int32_pred(_solution_map);
            loop_invariant (\unfolding [1\2]_int32_pred(_solution_map) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_index0 <= _solution_map[_0] && _solution_map[_0] < _n_dir_sol + _solution_index0));
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_0_pred(_v_res0_0, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_1_pred(_v_res0_1, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_2_pred(_v_res0_2, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_3_pred(_v_res0_3, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_4_pred(_v_res0_4, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_5_pred(_v_res0_5, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_6_pred(_v_res0_6, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_7_pred(_v_res0_7, _v, 0, _n_vis):});
            loop_invariant (\forall* int _v_res_out_s0_i_forall, int _v_res_out_s0_c_forall; 0 <= _v_res_out_s0_i_forall && _v_res_out_s0_i_forall < 2 && 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; {:v_res_out_pred(_v_res_out, _v_res_out_s0_c_forall, 0, 2, _v_res_out_s0_i_forall, 0, 2, _v_res_out_s0_j, 0, 2, _v_res_out_s0_v, 0, _n_vis):});
           @*/
           for (int _v_res_out_s0_i = 0; _v_res_out_s0_i < 0 + 2; _v_res_out_s0_i++)
           {
            bool _t3694 = (_v_res_out_s0_i == 1);
            bool _t3692 = (_v_res_out_s0_i == 0);
            int32_t _t3695 = ((_v_res_out_s0_i * 2) + _t3691);
            /*@
             loop_invariant 0 <= _v_res_out_s0_c && _v_res_out_s0_c <= 0 + 2;
             loop_invariant [1\2]_int32_pred(_ant1);
             loop_invariant (\unfolding [1\2]_int32_pred(_ant1) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant1[_0] && _ant1[_0] < _n_antennas));
             loop_invariant [1\2]_int32_pred(_ant2);
             loop_invariant (\unfolding [1\2]_int32_pred(_ant2) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; 0 <= _ant2[_0] && _ant2[_0] < _n_antennas));
             loop_invariant [1\2]_float32_pred(_model_);
             loop_invariant [1\2]_float64_pred(_sol_);
             loop_invariant [1\2]_int32_pred(_solution_map);
             loop_invariant (\unfolding [1\2]_int32_pred(_solution_map) \in (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_index0 <= _solution_map[_0] && _solution_map[_0] < _n_dir_sol + _solution_index0));
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_0_pred(_v_res0_0, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_1_pred(_v_res0_1, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_2_pred(_v_res0_2, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_3_pred(_v_res0_3, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_4_pred(_v_res0_4, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_5_pred(_v_res0_5, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_6_pred(_v_res0_6, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v; 0 <= _v && _v < _n_vis; {:[1\2]v_res0_7_pred(_v_res0_7, _v, 0, _n_vis):});
             loop_invariant (\forall* int _v_res_out_s0_c_forall; 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; {:v_res_out_pred(_v_res_out, _v_res_out_s0_c_forall, 0, 2, _v_res_out_s0_i, 0, 2, _v_res_out_s0_j, 0, 2, _v_res_out_s0_v, 0, _n_vis):});
            @*/
            for (int _v_res_out_s0_c = 0; _v_res_out_s0_c < 0 + 2; _v_res_out_s0_c++)
            {
             bool _t3649 = (_v_res_out_s0_c == 0);
             bool _t3651 = (_t3649 && _t3692);
             int32_t _246 = 
             /*@ with
              unfold [1\2]_int32_pred(_ant2); @*/
              _ant2[_v_res_out_s0_v]
             /*@ then
              fold [1\2]_int32_pred(_ant2); @*/
             ;
             int32_t _t3653_s = _246;
             int32_t _247 = 
             /*@ with
              unfold [1\2]_int32_pred(_solution_map); @*/
              _solution_map[_v_res_out_s0_v]
             /*@ then
              fold [1\2]_int32_pred(_solution_map); @*/
             ;
             int32_t _t3654 = _247;
             int32_t _t3655 = ((_sol__stride_3 * _t3653_s) + (_t3654 * 4));
             double _248 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert (_t3655 + 1) == ((1 - 0)*1) + ((0 - 0)*2) + ((_t3654 - 0)*4) + ((_246 - 0)*_sol__stride_3);
              ghost lemma_4d_access(1, 0, 1, 2, 0, 0, 2, 2, _t3654, 0, 4, _n_solutions, _246, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[(_t3655 + 1)]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _249 = (float)(_248);
             float _t3656 = _249;
             int32_t _250 = 
             /*@ with
              unfold [1\2]_int32_pred(_ant1); @*/
              _ant1[_v_res_out_s0_v]
             /*@ then
              fold [1\2]_int32_pred(_ant1); @*/
             ;
             int32_t _t3657_s = _250;
             double _251 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert ((_t3654 * 4) + (_sol__stride_3 * _t3657_s)) == ((0 - 0)*1) + ((0 - 0)*2) + ((_t3654 - 0)*4) + ((_250 - 0)*_sol__stride_3);
              ghost lemma_4d_access(0, 0, 1, 2, 0, 0, 2, 2, _t3654, 0, 4, _n_solutions, _250, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[((_t3654 * 4) + (_sol__stride_3 * _t3657_s))]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _252 = (float)(_251);
             float _t3658 = _252;
             float _253 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 1)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3659 = _253;
             float _254 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[(_v_res_out_s0_v * 8)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3660 = _254;
             int32_t _t3661 = ((_sol__stride_3 * _t3657_s) + (_t3654 * 4));
             double _255 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert (_t3661 + 1) == ((1 - 0)*1) + ((0 - 0)*2) + ((_t3654 - 0)*4) + ((_250 - 0)*_sol__stride_3);
              ghost lemma_4d_access(1, 0, 1, 2, 0, 0, 2, 2, _t3654, 0, 4, _n_solutions, _250, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[(_t3661 + 1)]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _256 = (float)(_255);
             float _t3662 = _256;
             float _t3663 = ((_t3658 * _t3659) + (_t3660 * _t3662));
             float _t3664 = ((_t3658 * _t3660) - (_t3659 * _t3662));
             double _257 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert ((_t3654 * 4) + (_sol__stride_3 * _t3653_s)) == ((0 - 0)*1) + ((0 - 0)*2) + ((_t3654 - 0)*4) + ((_246 - 0)*_sol__stride_3);
              ghost lemma_4d_access(0, 0, 1, 2, 0, 0, 2, 2, _t3654, 0, 4, _n_solutions, _246, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[((_t3654 * 4) + (_sol__stride_3 * _t3653_s))]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _258 = (float)(_257);
             float _t3665 = _258;
             bool _t3666 = (_v_res_out_s0_c == 1);
             bool _t3667 = (_t3666 && _t3692);
             bool _t3669 = (_t3649 && _t3694);
             double _259 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert (_t3655 + 3) == ((1 - 0)*1) + ((1 - 0)*2) + ((_t3654 - 0)*4) + ((_246 - 0)*_sol__stride_3);
              ghost lemma_4d_access(1, 0, 1, 2, 1, 0, 2, 2, _t3654, 0, 4, _n_solutions, _246, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[(_t3655 + 3)]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _260 = (float)(_259);
             float _t3670 = _260;
             float _261 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 3)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3671 = _261;
             float _262 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 2)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3672 = _262;
             float _t3673 = ((_t3658 * _t3671) + (_t3662 * _t3672));
             float _t3674 = ((_t3658 * _t3672) - (_t3662 * _t3671));
             double _263 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert (_t3655 + 2) == ((0 - 0)*1) + ((1 - 0)*2) + ((_t3654 - 0)*4) + ((_246 - 0)*_sol__stride_3);
              ghost lemma_4d_access(0, 0, 1, 2, 1, 0, 2, 2, _t3654, 0, 4, _n_solutions, _246, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[(_t3655 + 2)]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _264 = (float)(_263);
             float _t3675 = _264;
             double _265 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert (_t3661 + 2) == ((0 - 0)*1) + ((1 - 0)*2) + ((_t3654 - 0)*4) + ((_250 - 0)*_sol__stride_3);
              ghost lemma_4d_access(0, 0, 1, 2, 1, 0, 2, 2, _t3654, 0, 4, _n_solutions, _250, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[(_t3661 + 2)]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _266 = (float)(_265);
             float _t3677 = _266;
             float _267 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 5)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3678 = _267;
             float _268 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 4)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3679 = _268;
             double _269 = 
             /*@ with
              unfold [1\2]_float64_pred(_sol_);
              assert (_t3661 + 3) == ((1 - 0)*1) + ((1 - 0)*2) + ((_t3654 - 0)*4) + ((_250 - 0)*_sol__stride_3);
              ghost lemma_4d_access(1, 0, 1, 2, 1, 0, 2, 2, _t3654, 0, 4, _n_solutions, _250, 0, _sol__stride_3, _n_antennas); @*/
              _sol_[(_t3661 + 3)]
             /*@ then
              fold [1\2]_float64_pred(_sol_); @*/
             ;
             float _270 = (float)(_269);
             float _t3680 = _270;
             float _t3681 = ((_t3677 * _t3678) + (_t3679 * _t3680));
             float _t3682 = ((_t3677 * _t3679) - (_t3678 * _t3680));
             float _271 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 7)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3683 = _271;
             float _272 = 
             /*@ with
              unfold [1\2]_float32_pred(_model_); @*/
              _model_[((_v_res_out_s0_v * 8) + 6)]
             /*@ then
              fold [1\2]_float32_pred(_model_); @*/
             ;
             float _t3684 = _272;
             float _t3685 = ((_t3677 * _t3683) + (_t3680 * _t3684));
             float _t3686 = ((_t3677 * _t3684) - (_t3680 * _t3683));
             float _273 = 
             /*@ with
              unfold [1\2]v_res0_0_pred(_v_res0_0, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_0[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_0_pred(_v_res0_0, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _274 = 
             /*@ with
              unfold [1\2]v_res0_1_pred(_v_res0_1, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_1[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_1_pred(_v_res0_1, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _275 = 
             /*@ with
              unfold [1\2]v_res0_2_pred(_v_res0_2, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_2[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_2_pred(_v_res0_2, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _276 = 
             /*@ with
              unfold [1\2]v_res0_3_pred(_v_res0_3, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_3[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_3_pred(_v_res0_3, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _277 = 
             /*@ with
              unfold [1\2]v_res0_4_pred(_v_res0_4, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_4[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_4_pred(_v_res0_4, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _278 = 
             /*@ with
              unfold [1\2]v_res0_5_pred(_v_res0_5, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_5[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_5_pred(_v_res0_5, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _279 = 
             /*@ with
              unfold [1\2]v_res0_6_pred(_v_res0_6, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_6[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_6_pred(_v_res0_6, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             float _280 = 
             /*@ with
              unfold [1\2]v_res0_7_pred(_v_res0_7, _v_res_out_s0_v, 0, _n_vis); @*/
              _v_res0_7[_v_res_out_s0_v]
             /*@ then
              fold [1\2]v_res0_7_pred(_v_res0_7, _v_res_out_s0_v, 0, _n_vis); @*/
             ;
             /*@
              unfold v_res_out_pred(_v_res_out, _v_res_out_s0_c, 0, 2, _v_res_out_s0_i, 0, 2, _v_res_out_s0_j, 0, 2, _v_res_out_s0_v, 0, _n_vis); @*/
             _v_res_out[(_t3695 + _v_res_out_s0_c)]= ((_t3651 && _t3688) ? (_273 + (((0.000000 - _t3656) * _t3663) - (_t3664 * _t3665))) : ((_t3667 && _t3688) ? (_274 - (((0.000000 - _t3656) * _t3664) + (_t3663 * _t3665))) : ((_t3669 && _t3688) ? (_275 + (((0.000000 - _t3670) * _t3673) - (_t3674 * _t3675))) : (((_t3666 && _t3694) && _t3688) ? (_276 - (((0.000000 - _t3670) * _t3674) + (_t3673 * _t3675))) : ((_t3651 && _t3690) ? (_277 + (((0.000000 - _t3656) * _t3681) - (_t3665 * _t3682))) : ((_t3667 && _t3690) ? (_278 - (((0.000000 - _t3656) * _t3682) + (_t3665 * _t3681))) : ((_t3669 && _t3690) ? (_279 + (((0.000000 - _t3670) * _t3685) - (_t3675 * _t3686))) : (_280 - (((0.000000 - _t3670) * _t3686) + (_t3675 * _t3685))))))))));
             /*@ fold v_res_out_pred(_v_res_out, _v_res_out_s0_c, 0, 2, _v_res_out_s0_i, 0, 2, _v_res_out_s0_j, 0, 2, _v_res_out_s0_v, 0, _n_vis); @*/
            } // for _v_res_out_s0_c
           } // for _v_res_out_s0_i
          } // for _v_res_out_s0_j
         } // for _v_res_out_s0_v
         /*@ ghost from_pred_v_res0_0(_v_res0_0, 0, _n_vis);
          @*/
         free(_v_res0_0);
         /*@ ghost from_pred_v_res0_1(_v_res0_1, 0, _n_vis);
          @*/
         free(_v_res0_1);
         /*@ ghost from_pred_v_res0_2(_v_res0_2, 0, _n_vis);
          @*/
         free(_v_res0_2);
         /*@ ghost from_pred_v_res0_3(_v_res0_3, 0, _n_vis);
          @*/
         free(_v_res0_3);
         /*@ ghost from_pred_v_res0_4(_v_res0_4, 0, _n_vis);
          @*/
         free(_v_res0_4);
         /*@ ghost from_pred_v_res0_5(_v_res0_5, 0, _n_vis);
          @*/
         free(_v_res0_5);
         /*@ ghost from_pred_v_res0_6(_v_res0_6, 0, _n_vis);
          @*/
         free(_v_res0_6);
         /*@ ghost from_pred_v_res0_7(_v_res0_7, 0, _n_vis);
          @*/
         free(_v_res0_7);
        } // alloc _v_res0_7
       } // alloc _v_res0_6
      } // alloc _v_res0_5
     } // alloc _v_res0_4
    } // alloc _v_res0_3
   } // alloc _v_res0_2
  } // alloc _v_res0_1
 } // alloc _v_res0_0
 return 0;
}

#ifdef __cplusplus
}  // extern "C"
#endif

