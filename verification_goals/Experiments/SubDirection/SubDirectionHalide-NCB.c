
/* MACHINE GENERATED By Halide. */

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#ifndef HALIVER_GLOBALS
#define HALIVER_GLOBALS

struct halide_dimension_t {
    int32_t min, extent, stride;
};

inline void halide_unused(bool e){};

/*@
pure int max(int x, int y) = x > y ? x : y;

pure int min(int x, int y) = x > y ? y : x;

pure float max(float x, float y) = x > y ? x : y;

pure float min(float x, float y) = x > y ? y : x;

pure int abs(int x) = x >= 0 ? x : -x;

pure float abs(float x) = x >= 0 ? x : -x;

// Euclidean division is defined internally in VerCors
pure int hdiv(int x, int y) = y == 0 ? 0 : \euclidean_div(x, y);
pure int hmod(int x, int y) = y == 0 ? 0 : \euclidean_mod(x, y);
@*/

/*@
  requires y != 0;
  ensures \result == \euclidean_div(x, y);
@*/
inline int /*@ pure @*/ div_eucl(int x, int y)
{
    int q = x/y;
    int r = x%y;
    return r < 0 ? q + (y > 0 ? -1 : 1) : q;
}

/*@
  requires y != 0;
  ensures \result == \euclidean_mod(x, y);
@*/
inline int /*@ pure @*/ mod_eucl(int x, int y)
{
    int r = x%y;
    return (x >= 0 || r == 0) ? r : r + abs(y);
}

static inline float /*@ pure @*/ fast_inverse_f32(float x) {return 1.0f/x;}
static inline float /*@ pure @*/ sqrt_f32(double x) {return (float)sqrt((double)x);}
static inline float /*@ pure @*/ pow_f32(float x, float y){ return (float) pow((double) x, (double) y);}
static inline float /*@ pure @*/ floor_f32(float x){ return (float) floor((double) x); }
static inline float /*@ pure @*/ ceil_f32(float x){ return (float) ceil((double) x); }
static inline float /*@ pure @*/ round_f32(float x){ return (float) round((double) x); }

static inline double /*@ pure @*/ sqrt_f64(double x) {return sqrt(x);}
static inline double /*@ pure @*/ pow_f64(double x, double y) {return pow(x, y);}
static inline double /*@ pure @*/ floor_f64(double x) {return floor(x);}
static inline double /*@ pure @*/ ceil_f64(double x) {return ceil(x);}
static inline double /*@ pure @*/ round_f64(double x){ return round(x); }

// inline float nan_f32() {return NAN;}
/*@
inline resource dim_perm(struct halide_dimension_t *dim, rational p, int i) = 
 Perm(&dim[i], 1\2) **
 Perm(dim[i].min, 1\2) **
 Perm(dim[i].stride, 1\2) **
 Perm(dim[i].extent, 1\2)
 ;


  ghost
  requires a >= 0;
  requires b > 0;
  requires a < max_a;
  ensures a*b <= (max_a-1)*b;
  decreases b;
void lemma_nonlinear(int a, int b, int max_a){
  if(b>1){
    lemma_nonlinear(a, b-1, max_a);
    assert a*(b-1) <= max_a*(b-1);
  }
}
@*/
#endif // HALIVER_GLOBALS

#ifndef HALIDE_BUFFER_TYPE_DOUBLE
#define HALIDE_BUFFER_TYPE_DOUBLE
struct halide_buffer_double {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    double *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline double *_halide_buffer_get_host_double(struct halide_buffer_double *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_double(struct halide_buffer_double *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_double(struct halide_buffer_double *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_DOUBLE
#ifndef HALIDE_BUFFER_TYPE_UINT32_T
#define HALIDE_BUFFER_TYPE_UINT32_T
struct halide_buffer_uint32_t {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    uint32_t *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline uint32_t *_halide_buffer_get_host_uint32_t(struct halide_buffer_uint32_t *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_uint32_t(struct halide_buffer_uint32_t *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_uint32_t(struct halide_buffer_uint32_t *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_uint32_t(struct halide_buffer_uint32_t *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_uint32_t(struct halide_buffer_uint32_t *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_uint32_t(struct halide_buffer_uint32_t *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_UINT32_T
#ifndef HALIDE_BUFFER_TYPE_FLOAT
#define HALIDE_BUFFER_TYPE_FLOAT
struct halide_buffer_float {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    float *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline float *_halide_buffer_get_host_float(struct halide_buffer_float *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_float(struct halide_buffer_float *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_FLOAT
//@ pure float pure_sol_(int x);
//@ pure int pure_solution_map(int x);
//@ pure int pure_ant1(int x);
//@ pure int pure_ant2(int x);
//@ pure float pure_model_(int x);
//@ pure float pure_v_res_in(int x);
//@ pure float pure_v_res_out(int x);



#ifdef __cplusplus
extern "C" {
#endif

/*@
 context buffer_double(_sol__buffer, 1\2, 4);
 context dim_perm(_sol__buffer->dim, 1\2, 0);
 context dim_perm(_sol__buffer->dim, 1\2, 1);
 context dim_perm(_sol__buffer->dim, 1\2, 2);
 context dim_perm(_sol__buffer->dim, 1\2, 3);
 context \pointer_length(_sol__buffer->host) == 1 * _sol__buffer->dim[0].extent * _sol__buffer->dim[1].extent * _sol__buffer->dim[2].extent * _sol__buffer->dim[3].extent;
 context buffer_uint32_t(_solution_map_buffer, 1\2, 1);
 context dim_perm(_solution_map_buffer->dim, 1\2, 0);
 context \pointer_length(_solution_map_buffer->host) == 1 * _solution_map_buffer->dim[0].extent;
 context buffer_uint32_t(_ant1_buffer, 1\2, 1);
 context dim_perm(_ant1_buffer->dim, 1\2, 0);
 context \pointer_length(_ant1_buffer->host) == 1 * _ant1_buffer->dim[0].extent;
 context buffer_uint32_t(_ant2_buffer, 1\2, 1);
 context dim_perm(_ant2_buffer->dim, 1\2, 0);
 context \pointer_length(_ant2_buffer->host) == 1 * _ant2_buffer->dim[0].extent;
 context buffer_float(_model__buffer, 1\2, 4);
 context dim_perm(_model__buffer->dim, 1\2, 0);
 context dim_perm(_model__buffer->dim, 1\2, 1);
 context dim_perm(_model__buffer->dim, 1\2, 2);
 context dim_perm(_model__buffer->dim, 1\2, 3);
 context \pointer_length(_model__buffer->host) == 1 * _model__buffer->dim[0].extent * _model__buffer->dim[1].extent * _model__buffer->dim[2].extent * _model__buffer->dim[3].extent;
 context buffer_float(_v_res_in_buffer, 1\2, 4);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 0);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 1);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 2);
 context dim_perm(_v_res_in_buffer->dim, 1\2, 3);
 context \pointer_length(_v_res_in_buffer->host) == 1 * _v_res_in_buffer->dim[0].extent * _v_res_in_buffer->dim[1].extent * _v_res_in_buffer->dim[2].extent * _v_res_in_buffer->dim[3].extent;
 context buffer_float(_v_res_out_buffer, 1\2, 4);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 0);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 1);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 2);
 context dim_perm(_v_res_out_buffer->dim, 1\2, 3);
 context \pointer_length(_v_res_out_buffer->host) == 1 * _v_res_out_buffer->dim[0].extent * _v_res_out_buffer->dim[1].extent * _v_res_out_buffer->dim[2].extent * _v_res_out_buffer->dim[3].extent;
 context _ant1_buffer->host != _solution_map_buffer->host;
 context _ant2_buffer->host != _solution_map_buffer->host;
 context _ant2_buffer->host != _ant1_buffer->host;
 context _model__buffer->host != _sol__buffer->host;
 context _v_res_in_buffer->host != _sol__buffer->host;
 context _v_res_in_buffer->host != _model__buffer->host;
 context _v_res_out_buffer->host != _sol__buffer->host;
 context _v_res_out_buffer->host != _model__buffer->host;
 context _v_res_out_buffer->host != _v_res_in_buffer->host;
 context _ant1_buffer->dim[0].min == 0 && _ant1_buffer->dim[0].extent == _n_vis && _ant1_buffer->dim[0].stride == 1;
 context (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant1_buffer->host[_0], 1\2));
 context (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant1_buffer->host[_0] == pure_ant1(_0));
 context _ant2_buffer->dim[0].min == 0 && _ant2_buffer->dim[0].extent == _n_vis && _ant2_buffer->dim[0].stride == 1;
 context (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant2_buffer->host[_0], 1\2));
 context (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant2_buffer->host[_0] == pure_ant2(_0));
 context _model__buffer->dim[0].min == 0 && _model__buffer->dim[0].extent == 2 && _model__buffer->dim[0].stride == 1;
 context _model__buffer->dim[1].min == 0 && _model__buffer->dim[1].extent == 2 && _model__buffer->dim[1].stride == 2;
 context _model__buffer->dim[2].min == 0 && _model__buffer->dim[2].extent == 2 && _model__buffer->dim[2].stride == 4;
 context _model__buffer->dim[3].min == 0 && _model__buffer->dim[3].extent == _n_vis && _model__buffer->dim[3].stride == 8;
 context (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_model__buffer->host[_3*8 + _2*4 + _1*2 + _0], 1\2));
 context (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _model__buffer->host[_3*8 + _2*4 + _1*2 + _0] == pure_model_(_3*8 + _2*4 + _1*2 + _0));
 context _sol__buffer->dim[0].min == 0 && _sol__buffer->dim[0].extent == 2 && _sol__buffer->dim[0].stride == 1;
 context _sol__buffer->dim[1].min == 0 && _sol__buffer->dim[1].extent == 2 && _sol__buffer->dim[1].stride == 2;
 context _sol__buffer->dim[2].min == 0 && _sol__buffer->dim[2].extent == _n_solutions && _sol__buffer->dim[2].stride == 4;
 context _sol__buffer->dim[3].min == 0 && _sol__buffer->dim[3].extent == _n_antennas && _sol__buffer->dim[3].stride == _n_solutions*4;
 context (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; Perm(&_sol__buffer->host[_3*_n_solutions*4 + _2*4 + _1*2 + _0], 1\2));
 context (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; _sol__buffer->host[_3*_n_solutions*4 + _2*4 + _1*2 + _0] == pure_sol_(_3*_n_solutions*4 + _2*4 + _1*2 + _0));
 context _solution_map_buffer->dim[0].min == 0 && _solution_map_buffer->dim[0].extent == _n_vis && _solution_map_buffer->dim[0].stride == 1;
 context (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_solution_map_buffer->host[_0], 1\2));
 context (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_map_buffer->host[_0] == pure_solution_map(_0));
 context _v_res_in_buffer->dim[0].min == 0 && _v_res_in_buffer->dim[0].extent == 2 && _v_res_in_buffer->dim[0].stride == 1;
 context _v_res_in_buffer->dim[1].min == 0 && _v_res_in_buffer->dim[1].extent == 2 && _v_res_in_buffer->dim[1].stride == 2;
 context _v_res_in_buffer->dim[2].min == 0 && _v_res_in_buffer->dim[2].extent == 2 && _v_res_in_buffer->dim[2].stride == 4;
 context _v_res_in_buffer->dim[3].min == 0 && _v_res_in_buffer->dim[3].extent == _n_vis && _v_res_in_buffer->dim[3].stride == 8;
 context (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_v_res_in_buffer->host[_3*8 + _2*4 + _1*2 + _0], 1\2));
 context (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _v_res_in_buffer->host[_3*8 + _2*4 + _1*2 + _0] == pure_v_res_in(_3*8 + _2*4 + _1*2 + _0));
 context _v_res_out_buffer->dim[0].min == 0 && _v_res_out_buffer->dim[0].extent == 2 && _v_res_out_buffer->dim[0].stride == 1;
 context _v_res_out_buffer->dim[1].min == 0 && _v_res_out_buffer->dim[1].extent == 2 && _v_res_out_buffer->dim[1].stride == 2;
 context _v_res_out_buffer->dim[2].min == 0 && _v_res_out_buffer->dim[2].extent == 2 && _v_res_out_buffer->dim[2].stride == 4;
 context _v_res_out_buffer->dim[3].min == 0 && _v_res_out_buffer->dim[3].extent == _n_vis && _v_res_out_buffer->dim[3].stride == 8;
 context (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_v_res_out_buffer->host[_3*8 + _2*4 + _1*2 + _0], 1\1));
 context_everywhere _solution_index0 >= 0 && _n_dir_sol >= 0 && _solution_index0 + _n_dir_sol <= _n_solutions;
 context_everywhere (\forall int _0; 0 <= _0 && _0 < _n_vis; {:pure_solution_map(_0):} >= _solution_index0 && {:pure_solution_map(_0):} < _solution_index0 + _n_dir_sol);
 context_everywhere (\forall int _0; 0 <= _0 && _0 < _n_vis; {:pure_ant1(_0):} >= 0 && {:pure_ant1(_0):} < _n_antennas);
 context_everywhere (\forall int _0; 0 <= _0 && _0 < _n_vis; {:pure_ant2(_0):} >= 0 && {:pure_ant2(_0):} < _n_antennas);
 context_everywhere _n_antennas > 0;
 context_everywhere _n_solutions > 0;
 context_everywhere _n_vis > 0;
 context_everywhere _n_dir_sol > 0;
@*/
int SubDirection(struct halide_buffer_double *_sol__buffer, struct halide_buffer_uint32_t *_solution_map_buffer, struct halide_buffer_uint32_t *_ant1_buffer, struct halide_buffer_uint32_t *_ant2_buffer, struct halide_buffer_float *_model__buffer, struct halide_buffer_float *_v_res_in_buffer, int32_t _solution_index0, int32_t _n_dir_sol, int32_t _n_vis, int32_t _n_solutions, int32_t _n_antennas, struct halide_buffer_float *_v_res_out_buffer) {
 uint32_t* _ant1 = _halide_buffer_get_host_uint32_t(_ant1_buffer);
 int32_t _ant1_min_0 = _halide_buffer_get_min_uint32_t(_ant1_buffer, 0);
 int32_t _ant1_extent_0 = _halide_buffer_get_extent_uint32_t(_ant1_buffer, 0);
 int32_t _ant1_stride_0 = _halide_buffer_get_stride_uint32_t(_ant1_buffer, 0);
 uint32_t* _ant2 = _halide_buffer_get_host_uint32_t(_ant2_buffer);
 int32_t _ant2_min_0 = _halide_buffer_get_min_uint32_t(_ant2_buffer, 0);
 int32_t _ant2_extent_0 = _halide_buffer_get_extent_uint32_t(_ant2_buffer, 0);
 int32_t _ant2_stride_0 = _halide_buffer_get_stride_uint32_t(_ant2_buffer, 0);
 float* _model_ = _halide_buffer_get_host_float(_model__buffer);
 int32_t _model__min_0 = _halide_buffer_get_min_float(_model__buffer, 0);
 int32_t _model__extent_0 = _halide_buffer_get_extent_float(_model__buffer, 0);
 int32_t _model__stride_0 = _halide_buffer_get_stride_float(_model__buffer, 0);
 int32_t _model__min_1 = _halide_buffer_get_min_float(_model__buffer, 1);
 int32_t _model__extent_1 = _halide_buffer_get_extent_float(_model__buffer, 1);
 int32_t _model__stride_1 = _halide_buffer_get_stride_float(_model__buffer, 1);
 int32_t _model__min_2 = _halide_buffer_get_min_float(_model__buffer, 2);
 int32_t _model__extent_2 = _halide_buffer_get_extent_float(_model__buffer, 2);
 int32_t _model__stride_2 = _halide_buffer_get_stride_float(_model__buffer, 2);
 int32_t _model__min_3 = _halide_buffer_get_min_float(_model__buffer, 3);
 int32_t _model__extent_3 = _halide_buffer_get_extent_float(_model__buffer, 3);
 int32_t _model__stride_3 = _halide_buffer_get_stride_float(_model__buffer, 3);
 double* _sol_ = _halide_buffer_get_host_double(_sol__buffer);
 int32_t _sol__min_0 = _halide_buffer_get_min_double(_sol__buffer, 0);
 int32_t _sol__extent_0 = _halide_buffer_get_extent_double(_sol__buffer, 0);
 int32_t _sol__stride_0 = _halide_buffer_get_stride_double(_sol__buffer, 0);
 int32_t _sol__min_1 = _halide_buffer_get_min_double(_sol__buffer, 1);
 int32_t _sol__extent_1 = _halide_buffer_get_extent_double(_sol__buffer, 1);
 int32_t _sol__stride_1 = _halide_buffer_get_stride_double(_sol__buffer, 1);
 int32_t _sol__min_2 = _halide_buffer_get_min_double(_sol__buffer, 2);
 int32_t _sol__extent_2 = _halide_buffer_get_extent_double(_sol__buffer, 2);
 int32_t _sol__stride_2 = _halide_buffer_get_stride_double(_sol__buffer, 2);
 int32_t _sol__min_3 = _halide_buffer_get_min_double(_sol__buffer, 3);
 int32_t _sol__extent_3 = _halide_buffer_get_extent_double(_sol__buffer, 3);
 int32_t _sol__stride_3 = _halide_buffer_get_stride_double(_sol__buffer, 3);
 uint32_t* _solution_map = _halide_buffer_get_host_uint32_t(_solution_map_buffer);
 int32_t _solution_map_min_0 = _halide_buffer_get_min_uint32_t(_solution_map_buffer, 0);
 int32_t _solution_map_extent_0 = _halide_buffer_get_extent_uint32_t(_solution_map_buffer, 0);
 int32_t _solution_map_stride_0 = _halide_buffer_get_stride_uint32_t(_solution_map_buffer, 0);
 float* _v_res_in = _halide_buffer_get_host_float(_v_res_in_buffer);
 int32_t _v_res_in_min_0 = _halide_buffer_get_min_float(_v_res_in_buffer, 0);
 int32_t _v_res_in_extent_0 = _halide_buffer_get_extent_float(_v_res_in_buffer, 0);
 int32_t _v_res_in_stride_0 = _halide_buffer_get_stride_float(_v_res_in_buffer, 0);
 int32_t _v_res_in_min_1 = _halide_buffer_get_min_float(_v_res_in_buffer, 1);
 int32_t _v_res_in_extent_1 = _halide_buffer_get_extent_float(_v_res_in_buffer, 1);
 int32_t _v_res_in_stride_1 = _halide_buffer_get_stride_float(_v_res_in_buffer, 1);
 int32_t _v_res_in_min_2 = _halide_buffer_get_min_float(_v_res_in_buffer, 2);
 int32_t _v_res_in_extent_2 = _halide_buffer_get_extent_float(_v_res_in_buffer, 2);
 int32_t _v_res_in_stride_2 = _halide_buffer_get_stride_float(_v_res_in_buffer, 2);
 int32_t _v_res_in_min_3 = _halide_buffer_get_min_float(_v_res_in_buffer, 3);
 int32_t _v_res_in_extent_3 = _halide_buffer_get_extent_float(_v_res_in_buffer, 3);
 int32_t _v_res_in_stride_3 = _halide_buffer_get_stride_float(_v_res_in_buffer, 3);
 float* _v_res_out = _halide_buffer_get_host_float(_v_res_out_buffer);
 int32_t _v_res_out_min_0 = _halide_buffer_get_min_float(_v_res_out_buffer, 0);
 int32_t _v_res_out_extent_0 = _halide_buffer_get_extent_float(_v_res_out_buffer, 0);
 int32_t _v_res_out_stride_0 = _halide_buffer_get_stride_float(_v_res_out_buffer, 0);
 int32_t _v_res_out_min_1 = _halide_buffer_get_min_float(_v_res_out_buffer, 1);
 int32_t _v_res_out_extent_1 = _halide_buffer_get_extent_float(_v_res_out_buffer, 1);
 int32_t _v_res_out_stride_1 = _halide_buffer_get_stride_float(_v_res_out_buffer, 1);
 int32_t _v_res_out_min_2 = _halide_buffer_get_min_float(_v_res_out_buffer, 2);
 int32_t _v_res_out_extent_2 = _halide_buffer_get_extent_float(_v_res_out_buffer, 2);
 int32_t _v_res_out_stride_2 = _halide_buffer_get_stride_float(_v_res_out_buffer, 2);
 int32_t _v_res_out_min_3 = _halide_buffer_get_min_float(_v_res_out_buffer, 3);
 int32_t _v_res_out_extent_3 = _halide_buffer_get_extent_float(_v_res_out_buffer, 3);
 int32_t _v_res_out_stride_3 = _halide_buffer_get_stride_float(_v_res_out_buffer, 3);
 halide_unused((_ant1_stride_0 == 1));
 halide_unused((_ant1_min_0 == 0));
 halide_unused((_ant1_extent_0 == _n_vis));
 halide_unused((_ant2_stride_0 == 1));
 halide_unused((_ant2_min_0 == 0));
 halide_unused((_ant2_extent_0 == _n_vis));
 halide_unused((_model__stride_0 == 1));
 halide_unused((_model__min_0 == 0));
 halide_unused((_model__extent_0 == 2));
 halide_unused((_model__stride_1 == 2));
 halide_unused((_model__min_1 == 0));
 halide_unused((_model__extent_1 == 2));
 halide_unused((_model__stride_2 == 4));
 halide_unused((_model__min_2 == 0));
 halide_unused((_model__extent_2 == 2));
 halide_unused((_model__stride_3 == 8));
 halide_unused((_model__min_3 == 0));
 halide_unused((_model__extent_3 == _n_vis));
 halide_unused((_sol__stride_0 == 1));
 halide_unused((_sol__min_0 == 0));
 halide_unused((_sol__extent_0 == 2));
 halide_unused((_sol__stride_1 == 2));
 halide_unused((_sol__min_1 == 0));
 halide_unused((_sol__extent_1 == 2));
 halide_unused((_sol__stride_2 == 4));
 halide_unused((_sol__min_2 == 0));
 halide_unused((_sol__extent_2 == _n_solutions));
 halide_unused((_sol__stride_3 == (_n_solutions * 4)));
 halide_unused((_sol__min_3 == 0));
 halide_unused((_sol__extent_3 == _n_antennas));
 halide_unused((_solution_map_stride_0 == 1));
 halide_unused((_solution_map_min_0 == 0));
 halide_unused((_solution_map_extent_0 == _n_vis));
 halide_unused((_v_res_in_stride_0 == 1));
 halide_unused((_v_res_in_min_0 == 0));
 halide_unused((_v_res_in_extent_0 == 2));
 halide_unused((_v_res_in_stride_1 == 2));
 halide_unused((_v_res_in_min_1 == 0));
 halide_unused((_v_res_in_extent_1 == 2));
 halide_unused((_v_res_in_stride_2 == 4));
 halide_unused((_v_res_in_min_2 == 0));
 halide_unused((_v_res_in_extent_2 == 2));
 halide_unused((_v_res_in_stride_3 == 8));
 halide_unused((_v_res_in_min_3 == 0));
 halide_unused((_v_res_in_extent_3 == _n_vis));
 halide_unused((_v_res_out_stride_0 == 1));
 halide_unused((_v_res_out_min_0 == 0));
 halide_unused((_v_res_out_extent_0 == 2));
 halide_unused((_v_res_out_stride_1 == 2));
 halide_unused((_v_res_out_min_1 == 0));
 halide_unused((_v_res_out_extent_1 == 2));
 halide_unused((_v_res_out_stride_2 == 4));
 halide_unused((_v_res_out_min_2 == 0));
 halide_unused((_v_res_out_extent_2 == 2));
 halide_unused((_v_res_out_stride_3 == 8));
 halide_unused((_v_res_out_min_3 == 0));
 halide_unused((_v_res_out_extent_3 == _n_vis));
 // produce v_res_out
 /*@
  loop_invariant 0 <= _v_res_out_s0_vis && _v_res_out_s0_vis <= 0 + _n_vis;
  loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant1[_0], 1\2));
  loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant1[_0] == pure_ant1(_0));
  loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant2[_0], 1\2));
  loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant2[_0] == pure_ant2(_0));
  loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_model_[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
  loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _model_[((_3*2 + _2)*2 + _1)*2 + _0] == pure_model_(((_3*2 + _2)*2 + _1)*2 + _0));
  loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; Perm(&_sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0], 1\2));
  loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; _sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0] == pure_sol_(((_3*_n_solutions + _2)*2 + _1)*2 + _0));
  loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_solution_map[_0], 1\2));
  loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_map[_0] == pure_solution_map(_0));
  loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_v_res_in[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
  loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _v_res_in[((_3*2 + _2)*2 + _1)*2 + _0] == pure_v_res_in(((_3*2 + _2)*2 + _1)*2 + _0));
  loop_invariant (\forall* int _v_res_out_s0_c_forall, int _v_res_out_s0_i_forall, int _v_res_out_s0_j_forall, int _v_res_out_s0_vis_forall; 0 <= _v_res_out_s0_vis_forall && _v_res_out_s0_vis_forall < _n_vis && 0 <= _v_res_out_s0_j_forall && _v_res_out_s0_j_forall < 2 && 0 <= _v_res_out_s0_i_forall && _v_res_out_s0_i_forall < 2 && 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; Perm(&_v_res_out[((_v_res_out_s0_vis_forall*2 + _v_res_out_s0_j_forall)*2 + _v_res_out_s0_i_forall)*2 + _v_res_out_s0_c_forall], 1\1));
 @*/
 for (int _v_res_out_s0_vis = 0; _v_res_out_s0_vis < 0 + _n_vis; _v_res_out_s0_vis++)
 {
  /*@
   loop_invariant 0 <= _v_res_out_s0_j && _v_res_out_s0_j <= 0 + 2;
   loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant1[_0], 1\2));
   loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant1[_0] == pure_ant1(_0));
   loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant2[_0], 1\2));
   loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant2[_0] == pure_ant2(_0));
   loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_model_[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
   loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _model_[((_3*2 + _2)*2 + _1)*2 + _0] == pure_model_(((_3*2 + _2)*2 + _1)*2 + _0));
   loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; Perm(&_sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0], 1\2));
   loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; _sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0] == pure_sol_(((_3*_n_solutions + _2)*2 + _1)*2 + _0));
   loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_solution_map[_0], 1\2));
   loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_map[_0] == pure_solution_map(_0));
   loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_v_res_in[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
   loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _v_res_in[((_3*2 + _2)*2 + _1)*2 + _0] == pure_v_res_in(((_3*2 + _2)*2 + _1)*2 + _0));
   loop_invariant (\forall* int _v_res_out_s0_c_forall, int _v_res_out_s0_i_forall, int _v_res_out_s0_j_forall; 0 <= _v_res_out_s0_j_forall && _v_res_out_s0_j_forall < 2 && 0 <= _v_res_out_s0_i_forall && _v_res_out_s0_i_forall < 2 && 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; Perm(&_v_res_out[_v_res_out_s0_vis*8 + (_v_res_out_s0_j_forall*2 + _v_res_out_s0_i_forall)*2 + _v_res_out_s0_c_forall], 1\1));
  @*/
  for (int _v_res_out_s0_j = 0; _v_res_out_s0_j < 0 + 2; _v_res_out_s0_j++)
  {
   bool _t5755 = (_v_res_out_s0_j == 1);
   bool _t5753 = (_v_res_out_s0_j == 0);
   int32_t _t5756 = (((_v_res_out_s0_vis * 2) + _v_res_out_s0_j) * 4);
   /*@
    loop_invariant 0 <= _v_res_out_s0_i && _v_res_out_s0_i <= 0 + 2;
    loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant1[_0], 1\2));
    loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant1[_0] == pure_ant1(_0));
    loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant2[_0], 1\2));
    loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant2[_0] == pure_ant2(_0));
    loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_model_[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
    loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _model_[((_3*2 + _2)*2 + _1)*2 + _0] == pure_model_(((_3*2 + _2)*2 + _1)*2 + _0));
    loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; Perm(&_sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0], 1\2));
    loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; _sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0] == pure_sol_(((_3*_n_solutions + _2)*2 + _1)*2 + _0));
    loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_solution_map[_0], 1\2));
    loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_map[_0] == pure_solution_map(_0));
    loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_v_res_in[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
    loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _v_res_in[((_3*2 + _2)*2 + _1)*2 + _0] == pure_v_res_in(((_3*2 + _2)*2 + _1)*2 + _0));
    loop_invariant (\forall* int _v_res_out_s0_c_forall, int _v_res_out_s0_i_forall; 0 <= _v_res_out_s0_i_forall && _v_res_out_s0_i_forall < 2 && 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; Perm(&_v_res_out[_v_res_out_s0_j*4 + _v_res_out_s0_vis*8 + _v_res_out_s0_i_forall*2 + _v_res_out_s0_c_forall], 1\1));
   @*/
   for (int _v_res_out_s0_i = 0; _v_res_out_s0_i < 0 + 2; _v_res_out_s0_i++)
   {
    bool _t5759 = (_v_res_out_s0_i == 1);
    bool _t5757 = (_v_res_out_s0_i == 0);
    int32_t _t5760 = ((_v_res_out_s0_i * 2) + _t5756);
    /*@
     loop_invariant 0 <= _v_res_out_s0_c && _v_res_out_s0_c <= 0 + 2;
     loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant1[_0], 1\2));
     loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant1[_0] == pure_ant1(_0));
     loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_ant2[_0], 1\2));
     loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _ant2[_0] == pure_ant2(_0));
     loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_model_[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
     loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _model_[((_3*2 + _2)*2 + _1)*2 + _0] == pure_model_(((_3*2 + _2)*2 + _1)*2 + _0));
     loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; Perm(&_sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0], 1\2));
     loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < _n_solutions && 0 <= _3 && _3 < _n_antennas; _sol_[((_3*_n_solutions + _2)*2 + _1)*2 + _0] == pure_sol_(((_3*_n_solutions + _2)*2 + _1)*2 + _0));
     loop_invariant (\forall* int _0; 0 <= _0 && _0 < _n_vis; Perm(&_solution_map[_0], 1\2));
     loop_invariant (\forall int _0; 0 <= _0 && _0 < _n_vis; _solution_map[_0] == pure_solution_map(_0));
     loop_invariant (\forall* int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; Perm(&_v_res_in[((_3*2 + _2)*2 + _1)*2 + _0], 1\2));
     loop_invariant (\forall int _0, int _1, int _2, int _3; 0 <= _0 && _0 < 2 && 0 <= _1 && _1 < 2 && 0 <= _2 && _2 < 2 && 0 <= _3 && _3 < _n_vis; _v_res_in[((_3*2 + _2)*2 + _1)*2 + _0] == pure_v_res_in(((_3*2 + _2)*2 + _1)*2 + _0));
     loop_invariant (\forall* int _v_res_out_s0_c_forall; 0 <= _v_res_out_s0_c_forall && _v_res_out_s0_c_forall < 2; Perm(&_v_res_out[_v_res_out_s0_i*2 + _v_res_out_s0_j*4 + _v_res_out_s0_vis*8 + _v_res_out_s0_c_forall], 1\1));
    @*/
    for (int _v_res_out_s0_c = 0; _v_res_out_s0_c < 0 + 2; _v_res_out_s0_c++)
    {
     bool _t5714 = (_v_res_out_s0_c == 0);
     bool _t5716 = (_t5714 && _t5757);
     int32_t _101 = (int32_t)(_ant2[_v_res_out_s0_vis]);
     int32_t _t5718 = (_sol__stride_3 * _101);
     int32_t _102 = (int32_t)(_solution_map[_v_res_out_s0_vis]);
     int32_t _t5719 = _102;
     float _103 = (float)(_sol_[(((_t5719 * 4) + _t5718) + 1)]);
     float _t5721 = _103;
     int32_t _104 = (int32_t)(_ant1[_v_res_out_s0_vis]);
     int32_t _t5722 = (_sol__stride_3 * _104);
     float _105 = (float)(_sol_[((_t5719 * 4) + _t5722)]);
     float _t5723 = _105;
     float _t5724 = _model_[((_v_res_out_s0_vis * 8) + 1)];
     float _t5725 = _model_[(_v_res_out_s0_vis * 8)];
     float _106 = (float)(_sol_[(((_t5719 * 4) + _t5722) + 1)]);
     float _t5727 = _106;
     float _t5728 = ((_t5723 * _t5724) + (_t5725 * _t5727));
     float _t5729 = ((_t5723 * _t5725) - (_t5724 * _t5727));
     float _107 = (float)(_sol_[((_t5719 * 4) + _t5718)]);
     float _t5730 = _107;
     bool _t5731 = (_v_res_out_s0_c == 1);
     bool _t5732 = (_t5731 && _t5757);
     bool _t5734 = (_t5714 && _t5759);
     float _108 = (float)(_sol_[(((_t5719 * 4) + _t5718) + 3)]);
     float _t5735 = _108;
     float _t5736 = _model_[((_v_res_out_s0_vis * 8) + 3)];
     float _t5737 = _model_[((_v_res_out_s0_vis * 8) + 2)];
     float _t5738 = ((_t5723 * _t5736) + (_t5727 * _t5737));
     float _t5739 = ((_t5723 * _t5737) - (_t5727 * _t5736));
     float _109 = (float)(_sol_[(((_t5719 * 4) + _t5718) + 2)]);
     float _t5740 = _109;
     float _110 = (float)(_sol_[(((_t5719 * 4) + _t5722) + 2)]);
     float _t5742 = _110;
     float _t5743 = _model_[((_v_res_out_s0_vis * 8) + 5)];
     float _t5744 = _model_[((_v_res_out_s0_vis * 8) + 4)];
     float _111 = (float)(_sol_[(((_t5719 * 4) + _t5722) + 3)]);
     float _t5745 = _111;
     float _t5746 = ((_t5742 * _t5743) + (_t5744 * _t5745));
     float _t5747 = ((_t5742 * _t5744) - (_t5743 * _t5745));
     float _t5748 = _model_[((_v_res_out_s0_vis * 8) + 7)];
     float _t5749 = _model_[((_v_res_out_s0_vis * 8) + 6)];
     float _t5750 = ((_t5742 * _t5748) + (_t5745 * _t5749));
     float _t5751 = ((_t5742 * _t5749) - (_t5745 * _t5748));
     _v_res_out[(_t5760 + _v_res_out_s0_c)] = ((_t5716 && _t5753) ? (_v_res_in[(_v_res_out_s0_vis * 8)] + (((0.000000 - _t5721) * _t5728) - (_t5729 * _t5730))) : ((_t5732 && _t5753) ? (_v_res_in[((_v_res_out_s0_vis * 8) + 1)] - (((0.000000 - _t5721) * _t5729) + (_t5728 * _t5730))) : ((_t5734 && _t5753) ? (_v_res_in[((_v_res_out_s0_vis * 8) + 2)] + (((0.000000 - _t5735) * _t5738) - (_t5739 * _t5740))) : (((_t5731 && _t5759) && _t5753) ? (_v_res_in[((_v_res_out_s0_vis * 8) + 3)] - (((0.000000 - _t5735) * _t5739) + (_t5738 * _t5740))) : ((_t5716 && _t5755) ? (_v_res_in[((_v_res_out_s0_vis * 8) + 4)] + (((0.000000 - _t5721) * _t5746) - (_t5730 * _t5747))) : ((_t5732 && _t5755) ? (_v_res_in[((_v_res_out_s0_vis * 8) + 5)] - (((0.000000 - _t5721) * _t5747) + (_t5730 * _t5746))) : ((_t5734 && _t5755) ? (_v_res_in[((_v_res_out_s0_vis * 8) + 6)] + (((0.000000 - _t5735) * _t5750) - (_t5740 * _t5751))) : (_v_res_in[((_v_res_out_s0_vis * 8) + 7)] - (((0.000000 - _t5735) * _t5751) + (_t5740 * _t5750))))))))));
    } // for _v_res_out_s0_c
   } // for _v_res_out_s0_i
  } // for _v_res_out_s0_j
 } // for _v_res_out_s0_vis
 return 0;
}

#ifdef __cplusplus
}  // extern "C"
#endif

