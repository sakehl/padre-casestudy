domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 0
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 0
  requires subtype2 >= 0
  requires subtype2 <= 0
  decreases 
{
  (subtype1 == 0 ==> true) && true
}

method lemmaNonlinear(tid: Int, a: Int, b: Int, maxA: Int)
  returns (res: Void)
  requires 0 <= a
  requires 0 < b
  requires a < maxA
  decreases b
  ensures a * b <= (maxA - 1) * b
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    exc := null
    if (1 < b) {
      res1 := lemmaNonlinear(tid, a, b - 1, maxA)
      assert a * (b - 1) <= maxA * (b - 1)
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma2dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires 0 < strideA
  requires 0 < strideB
  requires extentA * strideA <= strideB
  ensures 0 <= (a - minA) * strideA + (b - minB) * strideB
  ensures (a - minA) * strideA + (b - minB) * strideB < strideB * extentB
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemmaNonlinear(tid, a - minA, strideA, extentA)
    res2 := lemmaNonlinear(tid, b - minB, strideB, extentB)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma3dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int,
  extentC: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires 0 < strideA
  requires 0 < strideB
  requires 0 < strideC
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC <
    strideC * extentC
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemma2dAccess(tid, a, minA, strideA, extentA, b, minB, strideB,
      extentB)
    res2 := lemmaNonlinear(tid, c - minC, strideC, extentC)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma4dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int,
  extentC: Int, d: Int, minD: Int, strideD: Int, extentD: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires minD <= d
  requires d - minD < extentD
  requires 0 < strideA
  requires 0 < strideB
  requires 0 < strideC
  requires 0 < strideD
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  requires extentC * strideC <= strideD
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC +
    (d - minD) * strideD
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC +
    (d - minD) * strideD <
    strideD * extentD
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemma3dAccess(tid, a, minA, strideA, extentA, b, minB, strideB,
      extentB, c, minC, strideC, extentC)
    res2 := lemmaNonlinear(tid, d - minD, strideD, extentD)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method lemma5dAccess(tid: Int, a: Int, minA: Int, strideA: Int, extentA: Int,
  b: Int, minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int,
  extentC: Int, d: Int, minD: Int, strideD: Int, extentD: Int, e: Int, minE: Int,
  strideE: Int, extentE: Int)
  returns (res: Void)
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires minD <= d
  requires d - minD < extentD
  requires minE <= e
  requires e - minE < extentE
  requires 0 < strideA
  requires 0 < strideB
  requires 0 < strideC
  requires 0 < strideD
  requires 0 < strideE
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  requires extentC * strideC <= strideD
  requires extentD * strideD <= strideE
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC +
    (d - minD) * strideD +
    (e - minE) * strideE
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC +
    (d - minD) * strideD +
    (e - minE) * strideE <
    strideE * extentE
{
  {
    var exc: Ref
    var return: Void
    var res1: Void
    var res2: Void
    var flatten: Void
    exc := null
    res1 := lemma4dAccess(tid, a, minA, strideA, extentA, b, minB, strideB,
      extentB, c, minC, strideC, extentC, d, minD, strideD, extentD)
    res2 := lemmaNonlinear(tid, e - minE, strideE, extentE)
    flatten := unit()
    return := flatten
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method main(tid: Int, nSolutions: Int, nAntennas: Int) returns (res: Int)
  requires 0 < nSolutions
  requires 0 < nAntennas
{
  {
    var exc: Ref
    var return: Int
    var solStride3: Int
    var _101: Int
    var t5718: Int
    var t5719: Int
    var flatten: Int
    var flatten1: Int
    var res1: Void
    var res2: Void
    var res3: Void
    exc := null
    flatten := nSolutions * 4
    solStride3 := flatten
    inhale 0 <= _101 && _101 < nAntennas
    flatten1 := solStride3 * _101
    t5718 := flatten1
    inhale 0 <= t5719 && t5719 < nSolutions
    assert 4 * t5719 <= 4 * (nSolutions - 1)
    res1 := lemmaNonlinear(tid, 1, 1, 4)
    res2 := lemmaNonlinear(tid, t5719, 4, nSolutions)
    res3 := lemmaNonlinear(tid, _101, solStride3, nAntennas)
    assert t5719 * 4 + t5718 + 1 < nSolutions * nAntennas * 4
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}